
AVRASM ver. 2.1.51  C:\Users\Will\Documents\AVRStudio 5.1\AVRAssembler1\AVRAssembler1\AVRAssembler1.asm Fri Mar 26 02:13:15 2021

[builtin](2): Including file 'C:\Program Files (x86)\Atmel\AVR Studio 5.1\extensions\Atmel\AVRAssembler\2.1.51.17\AvrAssembler/Include\m88def.inc'
                 
                 ; Tests the ALU instructions
                 
                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega88.xml ************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m88def.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega88
                 ;* Date              : 2011-02-09
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega88
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M88DEF_INC_
                 #define _M88DEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATmega88
                 #pragma AVRPART ADMIN PART_NAME ATmega88
                 .equ   SIGNATURE_000   = 0x1e
                 .equ   SIGNATURE_001   = 0x93
                 .equ   SIGNATURE_002   = 0x0a
                 
                 #pragma AVRPART CORE CORE_VERSION V2E
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ   UDR0    = 0xc6  ; MEMORY MAPPED
                 .equ   UBRR0L  = 0xc4  ; MEMORY MAPPED
                 .equ   UBRR0H  = 0xc5  ; MEMORY MAPPED
                 .equ   UCSR0C  = 0xc2  ; MEMORY MAPPED
                 .equ   UCSR0B  = 0xc1  ; MEMORY MAPPED
                 .equ   UCSR0A  = 0xc0  ; MEMORY MAPPED
                 .equ   TWAMR   = 0xbd  ; MEMORY MAPPED
                 .equ   TWCR    = 0xbc  ; MEMORY MAPPED
                 .equ   TWDR    = 0xbb  ; MEMORY MAPPED
                 .equ   TWAR    = 0xba  ; MEMORY MAPPED
                 .equ   TWSR    = 0xb9  ; MEMORY MAPPED
                 .equ   TWBR    = 0xb8  ; MEMORY MAPPED
                 .equ   ASSR    = 0xb6  ; MEMORY MAPPED
                 .equ   OCR2B   = 0xb4  ; MEMORY MAPPED
                 .equ   OCR2A   = 0xb3  ; MEMORY MAPPED
                 .equ   TCNT2   = 0xb2  ; MEMORY MAPPED
                 .equ   TCCR2B  = 0xb1  ; MEMORY MAPPED
                 .equ   TCCR2A  = 0xb0  ; MEMORY MAPPED
                 .equ   OCR1BL  = 0x8a  ; MEMORY MAPPED
                 .equ   OCR1BH  = 0x8b  ; MEMORY MAPPED
                 .equ   OCR1AL  = 0x88  ; MEMORY MAPPED
                 .equ   OCR1AH  = 0x89  ; MEMORY MAPPED
                 .equ   ICR1L   = 0x86  ; MEMORY MAPPED
                 .equ   ICR1H   = 0x87  ; MEMORY MAPPED
                 .equ   TCNT1L  = 0x84  ; MEMORY MAPPED
                 .equ   TCNT1H  = 0x85  ; MEMORY MAPPED
                 .equ   TCCR1C  = 0x82  ; MEMORY MAPPED
                 .equ   TCCR1B  = 0x81  ; MEMORY MAPPED
                 .equ   TCCR1A  = 0x80  ; MEMORY MAPPED
                 .equ   DIDR1   = 0x7f  ; MEMORY MAPPED
                 .equ   DIDR0   = 0x7e  ; MEMORY MAPPED
                 .equ   ADMUX   = 0x7c  ; MEMORY MAPPED
                 .equ   ADCSRB  = 0x7b  ; MEMORY MAPPED
                 .equ   ADCSRA  = 0x7a  ; MEMORY MAPPED
                 .equ   ADCH    = 0x79  ; MEMORY MAPPED
                 .equ   ADCL    = 0x78  ; MEMORY MAPPED
                 .equ   TIMSK2  = 0x70  ; MEMORY MAPPED
                 .equ   TIMSK1  = 0x6f  ; MEMORY MAPPED
                 .equ   TIMSK0  = 0x6e  ; MEMORY MAPPED
                 .equ   PCMSK1  = 0x6c  ; MEMORY MAPPED
                 .equ   PCMSK2  = 0x6d  ; MEMORY MAPPED
                 .equ   PCMSK0  = 0x6b  ; MEMORY MAPPED
                 .equ   EICRA   = 0x69  ; MEMORY MAPPED
                 .equ   PCICR   = 0x68  ; MEMORY MAPPED
                 .equ   OSCCAL  = 0x66  ; MEMORY MAPPED
                 .equ   PRR     = 0x64  ; MEMORY MAPPED
                 .equ   CLKPR   = 0x61  ; MEMORY MAPPED
                 .equ   WDTCSR  = 0x60  ; MEMORY MAPPED
                 .equ   SREG    = 0x3f
                 .equ   SPL     = 0x3d
                 .equ   SPH     = 0x3e
                 .equ   SPMCSR  = 0x37
                 .equ   MCUCR   = 0x35
                 .equ   MCUSR   = 0x34
                 .equ   SMCR    = 0x33
                 .equ   ACSR    = 0x30
                 .equ   SPDR    = 0x2e
                 .equ   SPSR    = 0x2d
                 .equ   SPCR    = 0x2c
                 .equ   GPIOR2  = 0x2b
                 .equ   GPIOR1  = 0x2a
                 .equ   OCR0B   = 0x28
                 .equ   OCR0A   = 0x27
                 .equ   TCNT0   = 0x26
                 .equ   TCCR0B  = 0x25
                 .equ   TCCR0A  = 0x24
                 .equ   GTCCR   = 0x23
                 .equ   EEARH   = 0x22
                 .equ   EEARL   = 0x21
                 .equ   EEDR    = 0x20
                 .equ   EECR    = 0x1f
                 .equ   GPIOR0  = 0x1e
                 .equ   EIMSK   = 0x1d
                 .equ   EIFR    = 0x1c
                 .equ   PCIFR   = 0x1b
                 .equ   TIFR2   = 0x17
                 .equ   TIFR1   = 0x16
                 .equ   TIFR0   = 0x15
                 .equ   PORTD   = 0x0b
                 .equ   DDRD    = 0x0a
                 .equ   PIND    = 0x09
                 .equ   PORTC   = 0x08
                 .equ   DDRC    = 0x07
                 .equ   PINC    = 0x06
                 .equ   PORTB   = 0x05
                 .equ   DDRB    = 0x04
                 .equ   PINB    = 0x03
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** USART0 ***********************
                 ; UDR0 - USART I/O Data Register
                 .equ   UDR0_0  = 0     ; USART I/O Data Register bit 0
                 .equ   UDR0_1  = 1     ; USART I/O Data Register bit 1
                 .equ   UDR0_2  = 2     ; USART I/O Data Register bit 2
                 .equ   UDR0_3  = 3     ; USART I/O Data Register bit 3
                 .equ   UDR0_4  = 4     ; USART I/O Data Register bit 4
                 .equ   UDR0_5  = 5     ; USART I/O Data Register bit 5
                 .equ   UDR0_6  = 6     ; USART I/O Data Register bit 6
                 .equ   UDR0_7  = 7     ; USART I/O Data Register bit 7
                 
                 ; UCSR0A - USART Control and Status Register A
                 .equ   MPCM0   = 0     ; Multi-processor Communication Mode
                 .equ   U2X0    = 1     ; Double the USART transmission speed
                 .equ   UPE0    = 2     ; Parity Error
                 .equ   DOR0    = 3     ; Data overRun
                 .equ   FE0     = 4     ; Framing Error
                 .equ   UDRE0   = 5     ; USART Data Register Empty
                 .equ   TXC0    = 6     ; USART Transmitt Complete
                 .equ   RXC0    = 7     ; USART Receive Complete
                 
                 ; UCSR0B - USART Control and Status Register B
                 .equ   TXB80   = 0     ; Transmit Data Bit 8
                 .equ   RXB80   = 1     ; Receive Data Bit 8
                 .equ   UCSZ02  = 2     ; Character Size
                 .equ   TXEN0   = 3     ; Transmitter Enable
                 .equ   RXEN0   = 4     ; Receiver Enable
                 .equ   UDRIE0  = 5     ; USART Data register Empty Interrupt Enable
                 .equ   TXCIE0  = 6     ; TX Complete Interrupt Enable
                 .equ   RXCIE0  = 7     ; RX Complete Interrupt Enable
                 
                 ; UCSR0C - USART Control and Status Register C
                 .equ   UCPOL0  = 0     ; Clock Polarity
                 .equ   UCSZ00  = 1     ; Character Size
                 .equ   UCPHA0  = UCSZ00        ; For compatibility
                 .equ   UCSZ01  = 2     ; Character Size
                 .equ   UDORD0  = UCSZ01        ; For compatibility
                 .equ   USBS0   = 3     ; Stop Bit Select
                 .equ   UPM00   = 4     ; Parity Mode Bit 0
                 .equ   UPM01   = 5     ; Parity Mode Bit 1
                 .equ   UMSEL00 = 6     ; USART Mode Select
                 .equ   UMSEL0  = UMSEL00       ; For compatibility
                 .equ   UMSEL01 = 7     ; USART Mode Select
                 .equ   UMSEL1  = UMSEL01       ; For compatibility
                 
                 ; UBRR0H - USART Baud Rate Register High Byte
                 .equ   UBRR8   = 0     ; USART Baud Rate Register bit 8
                 .equ   UBRR9   = 1     ; USART Baud Rate Register bit 9
                 .equ   UBRR10  = 2     ; USART Baud Rate Register bit 10
                 .equ   UBRR11  = 3     ; USART Baud Rate Register bit 11
                 
                 ; UBRR0L - USART Baud Rate Register Low Byte
                 .equ   _UBRR0  = 0     ; USART Baud Rate Register bit 0
                 .equ   _UBRR1  = 1     ; USART Baud Rate Register bit 1
                 .equ   UBRR2   = 2     ; USART Baud Rate Register bit 2
                 .equ   UBRR3   = 3     ; USART Baud Rate Register bit 3
                 .equ   UBRR4   = 4     ; USART Baud Rate Register bit 4
                 .equ   UBRR5   = 5     ; USART Baud Rate Register bit 5
                 .equ   UBRR6   = 6     ; USART Baud Rate Register bit 6
                 .equ   UBRR7   = 7     ; USART Baud Rate Register bit 7
                 
                 
                 ; ***** TWI **************************
                 ; TWAMR - TWI (Slave) Address Mask Register
                 .equ   TWAM0   = 1     ; 
                 .equ   TWAMR0  = TWAM0 ; For compatibility
                 .equ   TWAM1   = 2     ; 
                 .equ   TWAMR1  = TWAM1 ; For compatibility
                 .equ   TWAM2   = 3     ; 
                 .equ   TWAMR2  = TWAM2 ; For compatibility
                 .equ   TWAM3   = 4     ; 
                 .equ   TWAMR3  = TWAM3 ; For compatibility
                 .equ   TWAM4   = 5     ; 
                 .equ   TWAMR4  = TWAM4 ; For compatibility
                 .equ   TWAM5   = 6     ; 
                 .equ   TWAMR5  = TWAM5 ; For compatibility
                 .equ   TWAM6   = 7     ; 
                 .equ   TWAMR6  = TWAM6 ; For compatibility
                 
                 ; TWBR - TWI Bit Rate register
                 .equ   TWBR0   = 0     ; 
                 .equ   TWBR1   = 1     ; 
                 .equ   TWBR2   = 2     ; 
                 .equ   TWBR3   = 3     ; 
                 .equ   TWBR4   = 4     ; 
                 .equ   TWBR5   = 5     ; 
                 .equ   TWBR6   = 6     ; 
                 .equ   TWBR7   = 7     ; 
                 
                 ; TWCR - TWI Control Register
                 .equ   TWIE    = 0     ; TWI Interrupt Enable
                 .equ   TWEN    = 2     ; TWI Enable Bit
                 .equ   TWWC    = 3     ; TWI Write Collition Flag
                 .equ   TWSTO   = 4     ; TWI Stop Condition Bit
                 .equ   TWSTA   = 5     ; TWI Start Condition Bit
                 .equ   TWEA    = 6     ; TWI Enable Acknowledge Bit
                 .equ   TWINT   = 7     ; TWI Interrupt Flag
                 
                 ; TWSR - TWI Status Register
                 .equ   TWPS0   = 0     ; TWI Prescaler
                 .equ   TWPS1   = 1     ; TWI Prescaler
                 .equ   TWS3    = 3     ; TWI Status
                 .equ   TWS4    = 4     ; TWI Status
                 .equ   TWS5    = 5     ; TWI Status
                 .equ   TWS6    = 6     ; TWI Status
                 .equ   TWS7    = 7     ; TWI Status
                 
                 ; TWDR - TWI Data register
                 .equ   TWD0    = 0     ; TWI Data Register Bit 0
                 .equ   TWD1    = 1     ; TWI Data Register Bit 1
                 .equ   TWD2    = 2     ; TWI Data Register Bit 2
                 .equ   TWD3    = 3     ; TWI Data Register Bit 3
                 .equ   TWD4    = 4     ; TWI Data Register Bit 4
                 .equ   TWD5    = 5     ; TWI Data Register Bit 5
                 .equ   TWD6    = 6     ; TWI Data Register Bit 6
                 .equ   TWD7    = 7     ; TWI Data Register Bit 7
                 
                 ; TWAR - TWI (Slave) Address register
                 .equ   TWGCE   = 0     ; TWI General Call Recognition Enable Bit
                 .equ   TWA0    = 1     ; TWI (Slave) Address register Bit 0
                 .equ   TWA1    = 2     ; TWI (Slave) Address register Bit 1
                 .equ   TWA2    = 3     ; TWI (Slave) Address register Bit 2
                 .equ   TWA3    = 4     ; TWI (Slave) Address register Bit 3
                 .equ   TWA4    = 5     ; TWI (Slave) Address register Bit 4
                 .equ   TWA5    = 6     ; TWI (Slave) Address register Bit 5
                 .equ   TWA6    = 7     ; TWI (Slave) Address register Bit 6
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TIMSK1 - Timer/Counter Interrupt Mask Register
                 .equ   TOIE1   = 0     ; Timer/Counter1 Overflow Interrupt Enable
                 .equ   OCIE1A  = 1     ; Timer/Counter1 Output CompareA Match Interrupt Enable
                 .equ   OCIE1B  = 2     ; Timer/Counter1 Output CompareB Match Interrupt Enable
                 .equ   ICIE1   = 5     ; Timer/Counter1 Input Capture Interrupt Enable
                 
                 ; TIFR1 - Timer/Counter Interrupt Flag register
                 .equ   TOV1    = 0     ; Timer/Counter1 Overflow Flag
                 .equ   OCF1A   = 1     ; Output Compare Flag 1A
                 .equ   OCF1B   = 2     ; Output Compare Flag 1B
                 .equ   ICF1    = 5     ; Input Capture Flag 1
                 
                 ; TCCR1A - Timer/Counter1 Control Register A
                 .equ   WGM10   = 0     ; Waveform Generation Mode
                 .equ   WGM11   = 1     ; Waveform Generation Mode
                 .equ   COM1B0  = 4     ; Compare Output Mode 1B, bit 0
                 .equ   COM1B1  = 5     ; Compare Output Mode 1B, bit 1
                 .equ   COM1A0  = 6     ; Comparet Ouput Mode 1A, bit 0
                 .equ   COM1A1  = 7     ; Compare Output Mode 1A, bit 1
                 
                 ; TCCR1B - Timer/Counter1 Control Register B
                 .equ   CS10    = 0     ; Prescaler source of Timer/Counter 1
                 .equ   CS11    = 1     ; Prescaler source of Timer/Counter 1
                 .equ   CS12    = 2     ; Prescaler source of Timer/Counter 1
                 .equ   WGM12   = 3     ; Waveform Generation Mode
                 .equ   WGM13   = 4     ; Waveform Generation Mode
                 .equ   ICES1   = 6     ; Input Capture 1 Edge Select
                 .equ   ICNC1   = 7     ; Input Capture 1 Noise Canceler
                 
                 ; TCCR1C - Timer/Counter1 Control Register C
                 .equ   FOC1B   = 6     ; 
                 .equ   FOC1A   = 7     ; 
                 
                 ; GTCCR - General Timer/Counter Control Register
                 .equ   PSRSYNC = 0     ; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ   TSM     = 7     ; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** TIMER_COUNTER_2 **************
                 ; TIMSK2 - Timer/Counter Interrupt Mask register
                 .equ   TOIE2   = 0     ; Timer/Counter2 Overflow Interrupt Enable
                 .equ   TOIE2A  = TOIE2 ; For compatibility
                 .equ   OCIE2A  = 1     ; Timer/Counter2 Output Compare Match A Interrupt Enable
                 .equ   OCIE2B  = 2     ; Timer/Counter2 Output Compare Match B Interrupt Enable
                 
                 ; TIFR2 - Timer/Counter Interrupt Flag Register
                 .equ   TOV2    = 0     ; Timer/Counter2 Overflow Flag
                 .equ   OCF2A   = 1     ; Output Compare Flag 2A
                 .equ   OCF2B   = 2     ; Output Compare Flag 2B
                 
                 ; TCCR2A - Timer/Counter2 Control Register A
                 .equ   WGM20   = 0     ; Waveform Genration Mode
                 .equ   WGM21   = 1     ; Waveform Genration Mode
                 .equ   COM2B0  = 4     ; Compare Output Mode bit 0
                 .equ   COM2B1  = 5     ; Compare Output Mode bit 1
                 .equ   COM2A0  = 6     ; Compare Output Mode bit 1
                 .equ   COM2A1  = 7     ; Compare Output Mode bit 1
                 
                 ; TCCR2B - Timer/Counter2 Control Register B
                 .equ   CS20    = 0     ; Clock Select bit 0
                 .equ   CS21    = 1     ; Clock Select bit 1
                 .equ   CS22    = 2     ; Clock Select bit 2
                 .equ   WGM22   = 3     ; Waveform Generation Mode
                 .equ   FOC2B   = 6     ; Force Output Compare B
                 .equ   FOC2A   = 7     ; Force Output Compare A
                 
                 ; TCNT2 - Timer/Counter2
                 .equ   TCNT2_0 = 0     ; Timer/Counter 2 bit 0
                 .equ   TCNT2_1 = 1     ; Timer/Counter 2 bit 1
                 .equ   TCNT2_2 = 2     ; Timer/Counter 2 bit 2
                 .equ   TCNT2_3 = 3     ; Timer/Counter 2 bit 3
                 .equ   TCNT2_4 = 4     ; Timer/Counter 2 bit 4
                 .equ   TCNT2_5 = 5     ; Timer/Counter 2 bit 5
                 .equ   TCNT2_6 = 6     ; Timer/Counter 2 bit 6
                 .equ   TCNT2_7 = 7     ; Timer/Counter 2 bit 7
                 
                 ; OCR2A - Timer/Counter2 Output Compare Register A
                 .equ   OCR2A_0 = 0     ; Timer/Counter2 Output Compare Register Bit 0
                 .equ   OCR2A_1 = 1     ; Timer/Counter2 Output Compare Register Bit 1
                 .equ   OCR2A_2 = 2     ; Timer/Counter2 Output Compare Register Bit 2
                 .equ   OCR2A_3 = 3     ; Timer/Counter2 Output Compare Register Bit 3
                 .equ   OCR2A_4 = 4     ; Timer/Counter2 Output Compare Register Bit 4
                 .equ   OCR2A_5 = 5     ; Timer/Counter2 Output Compare Register Bit 5
                 .equ   OCR2A_6 = 6     ; Timer/Counter2 Output Compare Register Bit 6
                 .equ   OCR2A_7 = 7     ; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; OCR2B - Timer/Counter2 Output Compare Register B
                 .equ   OCR2B_0 = 0     ; Timer/Counter2 Output Compare Register Bit 0
                 .equ   OCR2B_1 = 1     ; Timer/Counter2 Output Compare Register Bit 1
                 .equ   OCR2B_2 = 2     ; Timer/Counter2 Output Compare Register Bit 2
                 .equ   OCR2B_3 = 3     ; Timer/Counter2 Output Compare Register Bit 3
                 .equ   OCR2B_4 = 4     ; Timer/Counter2 Output Compare Register Bit 4
                 .equ   OCR2B_5 = 5     ; Timer/Counter2 Output Compare Register Bit 5
                 .equ   OCR2B_6 = 6     ; Timer/Counter2 Output Compare Register Bit 6
                 .equ   OCR2B_7 = 7     ; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; ASSR - Asynchronous Status Register
                 .equ   TCR2BUB = 0     ; Timer/Counter Control Register2 Update Busy
                 .equ   TCR2AUB = 1     ; Timer/Counter Control Register2 Update Busy
                 .equ   OCR2BUB = 2     ; Output Compare Register 2 Update Busy
                 .equ   OCR2AUB = 3     ; Output Compare Register2 Update Busy
                 .equ   TCN2UB  = 4     ; Timer/Counter2 Update Busy
                 .equ   AS2     = 5     ; Asynchronous Timer/Counter2
                 .equ   EXCLK   = 6     ; Enable External Clock Input
                 
                 ; GTCCR - General Timer Counter Control register
                 .equ   PSRASY  = 1     ; Prescaler Reset Timer/Counter2
                 .equ   PSR2    = PSRASY        ; For compatibility
                 ;.equ  TSM     = 7     ; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ   MUX0    = 0     ; Analog Channel and Gain Selection Bits
                 .equ   MUX1    = 1     ; Analog Channel and Gain Selection Bits
                 .equ   MUX2    = 2     ; Analog Channel and Gain Selection Bits
                 .equ   MUX3    = 3     ; Analog Channel and Gain Selection Bits
                 .equ   ADLAR   = 5     ; Left Adjust Result
                 .equ   REFS0   = 6     ; Reference Selection Bit 0
                 .equ   REFS1   = 7     ; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register A
                 .equ   ADPS0   = 0     ; ADC  Prescaler Select Bits
                 .equ   ADPS1   = 1     ; ADC  Prescaler Select Bits
                 .equ   ADPS2   = 2     ; ADC  Prescaler Select Bits
                 .equ   ADIE    = 3     ; ADC Interrupt Enable
                 .equ   ADIF    = 4     ; ADC Interrupt Flag
                 .equ   ADATE   = 5     ; ADC  Auto Trigger Enable
                 .equ   ADSC    = 6     ; ADC Start Conversion
                 .equ   ADEN    = 7     ; ADC Enable
                 
                 ; ADCSRB - The ADC Control and Status register B
                 .equ   ADTS0   = 0     ; ADC Auto Trigger Source bit 0
                 .equ   ADTS1   = 1     ; ADC Auto Trigger Source bit 1
                 .equ   ADTS2   = 2     ; ADC Auto Trigger Source bit 2
                 .equ   ACME    = 6     ; 
                 
                 ; ADCH - ADC Data Register High Byte
                 .equ   ADCH0   = 0     ; ADC Data Register High Byte Bit 0
                 .equ   ADCH1   = 1     ; ADC Data Register High Byte Bit 1
                 .equ   ADCH2   = 2     ; ADC Data Register High Byte Bit 2
                 .equ   ADCH3   = 3     ; ADC Data Register High Byte Bit 3
                 .equ   ADCH4   = 4     ; ADC Data Register High Byte Bit 4
                 .equ   ADCH5   = 5     ; ADC Data Register High Byte Bit 5
                 .equ   ADCH6   = 6     ; ADC Data Register High Byte Bit 6
                 .equ   ADCH7   = 7     ; ADC Data Register High Byte Bit 7
                 
                 ; ADCL - ADC Data Register Low Byte
                 .equ   ADCL0   = 0     ; ADC Data Register Low Byte Bit 0
                 .equ   ADCL1   = 1     ; ADC Data Register Low Byte Bit 1
                 .equ   ADCL2   = 2     ; ADC Data Register Low Byte Bit 2
                 .equ   ADCL3   = 3     ; ADC Data Register Low Byte Bit 3
                 .equ   ADCL4   = 4     ; ADC Data Register Low Byte Bit 4
                 .equ   ADCL5   = 5     ; ADC Data Register Low Byte Bit 5
                 .equ   ADCL6   = 6     ; ADC Data Register Low Byte Bit 6
                 .equ   ADCL7   = 7     ; ADC Data Register Low Byte Bit 7
                 
                 ; DIDR0 - Digital Input Disable Register
                 .equ   ADC0D   = 0     ; 
                 .equ   ADC1D   = 1     ; 
                 .equ   ADC2D   = 2     ; 
                 .equ   ADC3D   = 3     ; 
                 .equ   ADC4D   = 4     ; 
                 .equ   ADC5D   = 5     ; 
                 
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ   ACIS0   = 0     ; Analog Comparator Interrupt Mode Select bit 0
                 .equ   ACIS1   = 1     ; Analog Comparator Interrupt Mode Select bit 1
                 .equ   ACIC    = 2     ; Analog Comparator Input Capture Enable
                 .equ   ACIE    = 3     ; Analog Comparator Interrupt Enable
                 .equ   ACI     = 4     ; Analog Comparator Interrupt Flag
                 .equ   ACO     = 5     ; Analog Compare Output
                 .equ   ACBG    = 6     ; Analog Comparator Bandgap Select
                 .equ   ACD     = 7     ; Analog Comparator Disable
                 
                 ; DIDR1 - Digital Input Disable Register 1
                 .equ   AIN0D   = 0     ; AIN0 Digital Input Disable
                 .equ   AIN1D   = 1     ; AIN1 Digital Input Disable
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ   PORTB0  = 0     ; Port B Data Register bit 0
                 .equ   PB0     = 0     ; For compatibility
                 .equ   PORTB1  = 1     ; Port B Data Register bit 1
                 .equ   PB1     = 1     ; For compatibility
                 .equ   PORTB2  = 2     ; Port B Data Register bit 2
                 .equ   PB2     = 2     ; For compatibility
                 .equ   PORTB3  = 3     ; Port B Data Register bit 3
                 .equ   PB3     = 3     ; For compatibility
                 .equ   PORTB4  = 4     ; Port B Data Register bit 4
                 .equ   PB4     = 4     ; For compatibility
                 .equ   PORTB5  = 5     ; Port B Data Register bit 5
                 .equ   PB5     = 5     ; For compatibility
                 .equ   PORTB6  = 6     ; Port B Data Register bit 6
                 .equ   PB6     = 6     ; For compatibility
                 .equ   PORTB7  = 7     ; Port B Data Register bit 7
                 .equ   PB7     = 7     ; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ   DDB0    = 0     ; Port B Data Direction Register bit 0
                 .equ   DDB1    = 1     ; Port B Data Direction Register bit 1
                 .equ   DDB2    = 2     ; Port B Data Direction Register bit 2
                 .equ   DDB3    = 3     ; Port B Data Direction Register bit 3
                 .equ   DDB4    = 4     ; Port B Data Direction Register bit 4
                 .equ   DDB5    = 5     ; Port B Data Direction Register bit 5
                 .equ   DDB6    = 6     ; Port B Data Direction Register bit 6
                 .equ   DDB7    = 7     ; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ   PINB0   = 0     ; Port B Input Pins bit 0
                 .equ   PINB1   = 1     ; Port B Input Pins bit 1
                 .equ   PINB2   = 2     ; Port B Input Pins bit 2
                 .equ   PINB3   = 3     ; Port B Input Pins bit 3
                 .equ   PINB4   = 4     ; Port B Input Pins bit 4
                 .equ   PINB5   = 5     ; Port B Input Pins bit 5
                 .equ   PINB6   = 6     ; Port B Input Pins bit 6
                 .equ   PINB7   = 7     ; Port B Input Pins bit 7
                 
                 
                 ; ***** PORTC ************************
                 ; PORTC - Port C Data Register
                 .equ   PORTC0  = 0     ; Port C Data Register bit 0
                 .equ   PC0     = 0     ; For compatibility
                 .equ   PORTC1  = 1     ; Port C Data Register bit 1
                 .equ   PC1     = 1     ; For compatibility
                 .equ   PORTC2  = 2     ; Port C Data Register bit 2
                 .equ   PC2     = 2     ; For compatibility
                 .equ   PORTC3  = 3     ; Port C Data Register bit 3
                 .equ   PC3     = 3     ; For compatibility
                 .equ   PORTC4  = 4     ; Port C Data Register bit 4
                 .equ   PC4     = 4     ; For compatibility
                 .equ   PORTC5  = 5     ; Port C Data Register bit 5
                 .equ   PC5     = 5     ; For compatibility
                 .equ   PORTC6  = 6     ; Port C Data Register bit 6
                 .equ   PC6     = 6     ; For compatibility
                 
                 ; DDRC - Port C Data Direction Register
                 .equ   DDC0    = 0     ; Port C Data Direction Register bit 0
                 .equ   DDC1    = 1     ; Port C Data Direction Register bit 1
                 .equ   DDC2    = 2     ; Port C Data Direction Register bit 2
                 .equ   DDC3    = 3     ; Port C Data Direction Register bit 3
                 .equ   DDC4    = 4     ; Port C Data Direction Register bit 4
                 .equ   DDC5    = 5     ; Port C Data Direction Register bit 5
                 .equ   DDC6    = 6     ; Port C Data Direction Register bit 6
                 
                 ; PINC - Port C Input Pins
                 .equ   PINC0   = 0     ; Port C Input Pins bit 0
                 .equ   PINC1   = 1     ; Port C Input Pins bit 1
                 .equ   PINC2   = 2     ; Port C Input Pins bit 2
                 .equ   PINC3   = 3     ; Port C Input Pins bit 3
                 .equ   PINC4   = 4     ; Port C Input Pins bit 4
                 .equ   PINC5   = 5     ; Port C Input Pins bit 5
                 .equ   PINC6   = 6     ; Port C Input Pins bit 6
                 
                 
                 ; ***** PORTD ************************
                 ; PORTD - Port D Data Register
                 .equ   PORTD0  = 0     ; Port D Data Register bit 0
                 .equ   PD0     = 0     ; For compatibility
                 .equ   PORTD1  = 1     ; Port D Data Register bit 1
                 .equ   PD1     = 1     ; For compatibility
                 .equ   PORTD2  = 2     ; Port D Data Register bit 2
                 .equ   PD2     = 2     ; For compatibility
                 .equ   PORTD3  = 3     ; Port D Data Register bit 3
                 .equ   PD3     = 3     ; For compatibility
                 .equ   PORTD4  = 4     ; Port D Data Register bit 4
                 .equ   PD4     = 4     ; For compatibility
                 .equ   PORTD5  = 5     ; Port D Data Register bit 5
                 .equ   PD5     = 5     ; For compatibility
                 .equ   PORTD6  = 6     ; Port D Data Register bit 6
                 .equ   PD6     = 6     ; For compatibility
                 .equ   PORTD7  = 7     ; Port D Data Register bit 7
                 .equ   PD7     = 7     ; For compatibility
                 
                 ; DDRD - Port D Data Direction Register
                 .equ   DDD0    = 0     ; Port D Data Direction Register bit 0
                 .equ   DDD1    = 1     ; Port D Data Direction Register bit 1
                 .equ   DDD2    = 2     ; Port D Data Direction Register bit 2
                 .equ   DDD3    = 3     ; Port D Data Direction Register bit 3
                 .equ   DDD4    = 4     ; Port D Data Direction Register bit 4
                 .equ   DDD5    = 5     ; Port D Data Direction Register bit 5
                 .equ   DDD6    = 6     ; Port D Data Direction Register bit 6
                 .equ   DDD7    = 7     ; Port D Data Direction Register bit 7
                 
                 ; PIND - Port D Input Pins
                 .equ   PIND0   = 0     ; Port D Input Pins bit 0
                 .equ   PIND1   = 1     ; Port D Input Pins bit 1
                 .equ   PIND2   = 2     ; Port D Input Pins bit 2
                 .equ   PIND3   = 3     ; Port D Input Pins bit 3
                 .equ   PIND4   = 4     ; Port D Input Pins bit 4
                 .equ   PIND5   = 5     ; Port D Input Pins bit 5
                 .equ   PIND6   = 6     ; Port D Input Pins bit 6
                 .equ   PIND7   = 7     ; Port D Input Pins bit 7
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                 .equ   TOIE0   = 0     ; Timer/Counter0 Overflow Interrupt Enable
                 .equ   OCIE0A  = 1     ; Timer/Counter0 Output Compare Match A Interrupt Enable
                 .equ   OCIE0B  = 2     ; Timer/Counter0 Output Compare Match B Interrupt Enable
                 
                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                 .equ   TOV0    = 0     ; Timer/Counter0 Overflow Flag
                 .equ   OCF0A   = 1     ; Timer/Counter0 Output Compare Flag 0A
                 .equ   OCF0B   = 2     ; Timer/Counter0 Output Compare Flag 0B
                 
                 ; TCCR0A - Timer/Counter  Control Register A
                 .equ   WGM00   = 0     ; Waveform Generation Mode
                 .equ   WGM01   = 1     ; Waveform Generation Mode
                 .equ   COM0B0  = 4     ; Compare Output Mode, Fast PWm
                 .equ   COM0B1  = 5     ; Compare Output Mode, Fast PWm
                 .equ   COM0A0  = 6     ; Compare Output Mode, Phase Correct PWM Mode
                 .equ   COM0A1  = 7     ; Compare Output Mode, Phase Correct PWM Mode
                 
                 ; TCCR0B - Timer/Counter Control Register B
                 .equ   CS00    = 0     ; Clock Select
                 .equ   CS01    = 1     ; Clock Select
                 .equ   CS02    = 2     ; Clock Select
                 .equ   WGM02   = 3     ; 
                 .equ   FOC0B   = 6     ; Force Output Compare B
                 .equ   FOC0A   = 7     ; Force Output Compare A
                 
                 ; TCNT0 - Timer/Counter0
                 .equ   TCNT0_0 = 0     ; 
                 .equ   TCNT0_1 = 1     ; 
                 .equ   TCNT0_2 = 2     ; 
                 .equ   TCNT0_3 = 3     ; 
                 .equ   TCNT0_4 = 4     ; 
                 .equ   TCNT0_5 = 5     ; 
                 .equ   TCNT0_6 = 6     ; 
                 .equ   TCNT0_7 = 7     ; 
                 
                 ; OCR0A - Timer/Counter0 Output Compare Register
                 .equ   OCR0A_0 = 0     ; 
                 .equ   OCR0A_1 = 1     ; 
                 .equ   OCR0A_2 = 2     ; 
                 .equ   OCR0A_3 = 3     ; 
                 .equ   OCR0A_4 = 4     ; 
                 .equ   OCR0A_5 = 5     ; 
                 .equ   OCR0A_6 = 6     ; 
                 .equ   OCR0A_7 = 7     ; 
                 
                 ; OCR0B - Timer/Counter0 Output Compare Register
                 .equ   OCR0B_0 = 0     ; 
                 .equ   OCR0B_1 = 1     ; 
                 .equ   OCR0B_2 = 2     ; 
                 .equ   OCR0B_3 = 3     ; 
                 .equ   OCR0B_4 = 4     ; 
                 .equ   OCR0B_5 = 5     ; 
                 .equ   OCR0B_6 = 6     ; 
                 .equ   OCR0B_7 = 7     ; 
                 
                 ; GTCCR - General Timer/Counter Control Register
                 ;.equ  PSRSYNC = 0     ; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ   PSR10   = PSRSYNC       ; For compatibility
                 ;.equ  TSM     = 7     ; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; EICRA - External Interrupt Control Register
                 .equ   ISC00   = 0     ; External Interrupt Sense Control 0 Bit 0
                 .equ   ISC01   = 1     ; External Interrupt Sense Control 0 Bit 1
                 .equ   ISC10   = 2     ; External Interrupt Sense Control 1 Bit 0
                 .equ   ISC11   = 3     ; External Interrupt Sense Control 1 Bit 1
                 
                 ; EIMSK - External Interrupt Mask Register
                 .equ   INT0    = 0     ; External Interrupt Request 0 Enable
                 .equ   INT1    = 1     ; External Interrupt Request 1 Enable
                 
                 ; EIFR - External Interrupt Flag Register
                 .equ   INTF0   = 0     ; External Interrupt Flag 0
                 .equ   INTF1   = 1     ; External Interrupt Flag 1
                 
                 ; PCICR - Pin Change Interrupt Control Register
                 .equ   PCIE0   = 0     ; Pin Change Interrupt Enable 0
                 .equ   PCIE1   = 1     ; Pin Change Interrupt Enable 1
                 .equ   PCIE2   = 2     ; Pin Change Interrupt Enable 2
                 
                 ; PCMSK2 - Pin Change Mask Register 2
                 .equ   PCINT16 = 0     ; Pin Change Enable Mask 16
                 .equ   PCINT17 = 1     ; Pin Change Enable Mask 17
                 .equ   PCINT18 = 2     ; Pin Change Enable Mask 18
                 .equ   PCINT19 = 3     ; Pin Change Enable Mask 19
                 .equ   PCINT20 = 4     ; Pin Change Enable Mask 20
                 .equ   PCINT21 = 5     ; Pin Change Enable Mask 21
                 .equ   PCINT22 = 6     ; Pin Change Enable Mask 22
                 .equ   PCINT23 = 7     ; Pin Change Enable Mask 23
                 
                 ; PCMSK1 - Pin Change Mask Register 1
                 .equ   PCINT8  = 0     ; Pin Change Enable Mask 8
                 .equ   PCINT9  = 1     ; Pin Change Enable Mask 9
                 .equ   PCINT10 = 2     ; Pin Change Enable Mask 10
                 .equ   PCINT11 = 3     ; Pin Change Enable Mask 11
                 .equ   PCINT12 = 4     ; Pin Change Enable Mask 12
                 .equ   PCINT13 = 5     ; Pin Change Enable Mask 13
                 .equ   PCINT14 = 6     ; Pin Change Enable Mask 14
                 
                 ; PCMSK0 - Pin Change Mask Register 0
                 .equ   PCINT0  = 0     ; Pin Change Enable Mask 0
                 .equ   PCINT1  = 1     ; Pin Change Enable Mask 1
                 .equ   PCINT2  = 2     ; Pin Change Enable Mask 2
                 .equ   PCINT3  = 3     ; Pin Change Enable Mask 3
                 .equ   PCINT4  = 4     ; Pin Change Enable Mask 4
                 .equ   PCINT5  = 5     ; Pin Change Enable Mask 5
                 .equ   PCINT6  = 6     ; Pin Change Enable Mask 6
                 .equ   PCINT7  = 7     ; Pin Change Enable Mask 7
                 
                 ; PCIFR - Pin Change Interrupt Flag Register
                 .equ   PCIF0   = 0     ; Pin Change Interrupt Flag 0
                 .equ   PCIF1   = 1     ; Pin Change Interrupt Flag 1
                 .equ   PCIF2   = 2     ; Pin Change Interrupt Flag 2
                 
                 
                 ; ***** SPI **************************
                 ; SPDR - SPI Data Register
                 .equ   SPDR0   = 0     ; SPI Data Register bit 0
                 .equ   SPDR1   = 1     ; SPI Data Register bit 1
                 .equ   SPDR2   = 2     ; SPI Data Register bit 2
                 .equ   SPDR3   = 3     ; SPI Data Register bit 3
                 .equ   SPDR4   = 4     ; SPI Data Register bit 4
                 .equ   SPDR5   = 5     ; SPI Data Register bit 5
                 .equ   SPDR6   = 6     ; SPI Data Register bit 6
                 .equ   SPDR7   = 7     ; SPI Data Register bit 7
                 
                 ; SPSR - SPI Status Register
                 .equ   SPI2X   = 0     ; Double SPI Speed Bit
                 .equ   WCOL    = 6     ; Write Collision Flag
                 .equ   SPIF    = 7     ; SPI Interrupt Flag
                 
                 ; SPCR - SPI Control Register
                 .equ   SPR0    = 0     ; SPI Clock Rate Select 0
                 .equ   SPR1    = 1     ; SPI Clock Rate Select 1
                 .equ   CPHA    = 2     ; Clock Phase
                 .equ   CPOL    = 3     ; Clock polarity
                 .equ   MSTR    = 4     ; Master/Slave Select
                 .equ   DORD    = 5     ; Data Order
                 .equ   SPE     = 6     ; SPI Enable
                 .equ   SPIE    = 7     ; SPI Interrupt Enable
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ   SREG_C  = 0     ; Carry Flag
                 .equ   SREG_Z  = 1     ; Zero Flag
                 .equ   SREG_N  = 2     ; Negative Flag
                 .equ   SREG_V  = 3     ; Two's Complement Overflow Flag
                 .equ   SREG_S  = 4     ; Sign Bit
                 .equ   SREG_H  = 5     ; Half Carry Flag
                 .equ   SREG_T  = 6     ; Bit Copy Storage
                 .equ   SREG_I  = 7     ; Global Interrupt Enable
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ   CAL0    = 0     ; Oscillator Calibration Value Bit0
                 .equ   CAL1    = 1     ; Oscillator Calibration Value Bit1
                 .equ   CAL2    = 2     ; Oscillator Calibration Value Bit2
                 .equ   CAL3    = 3     ; Oscillator Calibration Value Bit3
                 .equ   CAL4    = 4     ; Oscillator Calibration Value Bit4
                 .equ   CAL5    = 5     ; Oscillator Calibration Value Bit5
                 .equ   CAL6    = 6     ; Oscillator Calibration Value Bit6
                 .equ   CAL7    = 7     ; Oscillator Calibration Value Bit7
                 
                 ; CLKPR - Clock Prescale Register
                 .equ   CLKPS0  = 0     ; Clock Prescaler Select Bit 0
                 .equ   CLKPS1  = 1     ; Clock Prescaler Select Bit 1
                 .equ   CLKPS2  = 2     ; Clock Prescaler Select Bit 2
                 .equ   CLKPS3  = 3     ; Clock Prescaler Select Bit 3
                 .equ   CLKPCE  = 7     ; Clock Prescaler Change Enable
                 
                 ; SPMCSR - Store Program Memory Control and Status Register
                 .equ   SELFPRGEN       = 0     ; Self Programming Enable
                 .equ   PGERS   = 1     ; Page Erase
                 .equ   PGWRT   = 2     ; Page Write
                 .equ   BLBSET  = 3     ; Boot Lock Bit Set
                 .equ   RWWSRE  = 4     ; Read-While-Write section read enable
                 .equ   RWWSB   = 6     ; Read-While-Write Section Busy
                 .equ   SPMIE   = 7     ; SPM Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 .equ   IVCE    = 0     ; 
                 .equ   IVSEL   = 1     ; 
                 .equ   PUD     = 4     ; 
                 
                 ; MCUSR - MCU Status Register
                 .equ   PORF    = 0     ; Power-on reset flag
                 .equ   EXTRF   = 1     ; External Reset Flag
                 .equ   EXTREF  = EXTRF ; For compatibility
                 .equ   BORF    = 2     ; Brown-out Reset Flag
                 .equ   WDRF    = 3     ; Watchdog Reset Flag
                 
                 ; SMCR - 
                 .equ   SE      = 0     ; 
                 .equ   SM0     = 1     ; 
                 .equ   SM1     = 2     ; 
                 .equ   SM2     = 3     ; 
                 
                 ; GPIOR2 - General Purpose I/O Register 2
                 .equ   GPIOR20 = 0     ; 
                 .equ   GPIOR21 = 1     ; 
                 .equ   GPIOR22 = 2     ; 
                 .equ   GPIOR23 = 3     ; 
                 .equ   GPIOR24 = 4     ; 
                 .equ   GPIOR25 = 5     ; 
                 .equ   GPIOR26 = 6     ; 
                 .equ   GPIOR27 = 7     ; 
                 
                 ; GPIOR1 - General Purpose I/O Register 1
                 .equ   GPIOR10 = 0     ; 
                 .equ   GPIOR11 = 1     ; 
                 .equ   GPIOR12 = 2     ; 
                 .equ   GPIOR13 = 3     ; 
                 .equ   GPIOR14 = 4     ; 
                 .equ   GPIOR15 = 5     ; 
                 .equ   GPIOR16 = 6     ; 
                 .equ   GPIOR17 = 7     ; 
                 
                 ; GPIOR0 - General Purpose I/O Register 0
                 .equ   GPIOR00 = 0     ; 
                 .equ   GPIOR01 = 1     ; 
                 .equ   GPIOR02 = 2     ; 
                 .equ   GPIOR03 = 3     ; 
                 .equ   GPIOR04 = 4     ; 
                 .equ   GPIOR05 = 5     ; 
                 .equ   GPIOR06 = 6     ; 
                 .equ   GPIOR07 = 7     ; 
                 
                 ; PRR - Power Reduction Register
                 .equ   PRADC   = 0     ; Power Reduction ADC
                 .equ   PRUSART0        = 1     ; Power Reduction USART
                 .equ   PRSPI   = 2     ; Power Reduction Serial Peripheral Interface
                 .equ   PRTIM1  = 3     ; Power Reduction Timer/Counter1
                 .equ   PRTIM0  = 5     ; Power Reduction Timer/Counter0
                 .equ   PRTIM2  = 6     ; Power Reduction Timer/Counter2
                 .equ   PRTWI   = 7     ; Power Reduction TWI
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCSR - Watchdog Timer Control Register
                 .equ   WDP0    = 0     ; Watch Dog Timer Prescaler bit 0
                 .equ   WDP1    = 1     ; Watch Dog Timer Prescaler bit 1
                 .equ   WDP2    = 2     ; Watch Dog Timer Prescaler bit 2
                 .equ   WDE     = 3     ; Watch Dog Enable
                 .equ   WDCE    = 4     ; Watchdog Change Enable
                 .equ   WDP3    = 5     ; Watchdog Timer Prescaler Bit 3
                 .equ   WDIE    = 6     ; Watchdog Timeout Interrupt Enable
                 .equ   WDIF    = 7     ; Watchdog Timeout Interrupt Flag
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEARL - EEPROM Address Register Low Byte
                 .equ   EEAR0   = 0     ; EEPROM Read/Write Access Bit 0
                 .equ   EEAR1   = 1     ; EEPROM Read/Write Access Bit 1
                 .equ   EEAR2   = 2     ; EEPROM Read/Write Access Bit 2
                 .equ   EEAR3   = 3     ; EEPROM Read/Write Access Bit 3
                 .equ   EEAR4   = 4     ; EEPROM Read/Write Access Bit 4
                 .equ   EEAR5   = 5     ; EEPROM Read/Write Access Bit 5
                 .equ   EEAR6   = 6     ; EEPROM Read/Write Access Bit 6
                 .equ   EEAR7   = 7     ; EEPROM Read/Write Access Bit 7
                 
                 ; EEARH - EEPROM Address Register High Byte
                 .equ   EEAR8   = 0     ; EEPROM Read/Write Access Bit 0
                 
                 ; EEDR - EEPROM Data Register
                 .equ   EEDR0   = 0     ; EEPROM Data Register bit 0
                 .equ   EEDR1   = 1     ; EEPROM Data Register bit 1
                 .equ   EEDR2   = 2     ; EEPROM Data Register bit 2
                 .equ   EEDR3   = 3     ; EEPROM Data Register bit 3
                 .equ   EEDR4   = 4     ; EEPROM Data Register bit 4
                 .equ   EEDR5   = 5     ; EEPROM Data Register bit 5
                 .equ   EEDR6   = 6     ; EEPROM Data Register bit 6
                 .equ   EEDR7   = 7     ; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ   EERE    = 0     ; EEPROM Read Enable
                 .equ   EEPE    = 1     ; EEPROM Write Enable
                 .equ   EEMPE   = 2     ; EEPROM Master Write Enable
                 .equ   EERIE   = 3     ; EEPROM Ready Interrupt Enable
                 .equ   EEPM0   = 4     ; EEPROM Programming Mode Bit 0
                 .equ   EEPM1   = 5     ; EEPROM Programming Mode Bit 1
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ   LB1     = 0     ; Lock bit
                 .equ   LB2     = 1     ; Lock bit
                 .equ   BLB01   = 2     ; Boot Lock bit
                 .equ   BLB02   = 3     ; Boot Lock bit
                 .equ   BLB11   = 4     ; Boot lock bit
                 .equ   BLB12   = 5     ; Boot lock bit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ   CKSEL0  = 0     ; Select Clock Source
                 .equ   CKSEL1  = 1     ; Select Clock Source
                 .equ   CKSEL2  = 2     ; Select Clock Source
                 .equ   CKSEL3  = 3     ; Select Clock Source
                 .equ   SUT0    = 4     ; Select start-up time
                 .equ   SUT1    = 5     ; Select start-up time
                 .equ   CKOUT   = 6     ; Clock output
                 .equ   CKDIV8  = 7     ; Divide clock by 8
                 
                 ; HIGH fuse bits
                 .equ   BODLEVEL0       = 0     ; Brown-out Detector trigger level
                 .equ   BODLEVEL1       = 1     ; Brown-out Detector trigger level
                 .equ   BODLEVEL2       = 2     ; Brown-out Detector trigger level
                 .equ   EESAVE  = 3     ; EEPROM memory is preserved through chip erase
                 .equ   WDTON   = 4     ; Watchdog Timer Always On
                 .equ   SPIEN   = 5     ; Enable Serial programming and Data Downloading
                 .equ   DWEN    = 6     ; debugWIRE Enable
                 .equ   RSTDISBL        = 7     ; External reset disable
                 
                 ; EXTENDED fuse bits
                 .equ   BOOTRST = 0     ; Select reset vector
                 .equ   BOOTSZ0 = 1     ; Select boot size
                 .equ   BOOTSZ1 = 2     ; Select boot size
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def   XH      = r27
                 .def   XL      = r26
                 .def   YH      = r29
                 .def   YL      = r28
                 .def   ZH      = r31
                 .def   ZL      = r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ   FLASHEND        = 0x0fff        ; Note: Word address
                 .equ   IOEND   = 0x00ff
                 .equ   SRAM_START      = 0x0100
                 .equ   SRAM_SIZE       = 1024
                 .equ   RAMEND  = 0x04ff
                 .equ   XRAMEND = 0x0000
                 .equ   E2END   = 0x01ff
                 .equ   EEPROMEND       = 0x01ff
                 .equ   EEADRBITS       = 9
                 #pragma AVRPART MEMORY PROG_FLASH 8192
                 #pragma AVRPART MEMORY EEPROM 512
                 #pragma AVRPART MEMORY INT_SRAM SIZE 1024
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ   NRWW_START_ADDR = 0xc00
                 .equ   NRWW_STOP_ADDR  = 0xfff
                 .equ   RWW_START_ADDR  = 0x0
                 .equ   RWW_STOP_ADDR   = 0xbff
                 .equ   PAGESIZE        = 32
                 .equ   FIRSTBOOTSTART  = 0xf80
                 .equ   SECONDBOOTSTART = 0xf00
                 .equ   THIRDBOOTSTART  = 0xe00
                 .equ   FOURTHBOOTSTART = 0xc00
                 .equ   SMALLBOOTSTART  = FIRSTBOOTSTART
                 .equ   LARGEBOOTSTART  = FOURTHBOOTSTART
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ   INT0addr        = 0x0001        ; External Interrupt Request 0
                 .equ   INT1addr        = 0x0002        ; External Interrupt Request 1
                 .equ   PCI0addr        = 0x0003        ; Pin Change Interrupt Request 0
                 .equ   PCI1addr        = 0x0004        ; Pin Change Interrupt Request 0
                 .equ   PCI2addr        = 0x0005        ; Pin Change Interrupt Request 1
                 .equ   WDTaddr = 0x0006        ; Watchdog Time-out Interrupt
                 .equ   OC2Aaddr        = 0x0007        ; Timer/Counter2 Compare Match A
                 .equ   OC2Baddr        = 0x0008        ; Timer/Counter2 Compare Match A
                 .equ   OVF2addr        = 0x0009        ; Timer/Counter2 Overflow
                 .equ   ICP1addr        = 0x000a        ; Timer/Counter1 Capture Event
                 .equ   OC1Aaddr        = 0x000b        ; Timer/Counter1 Compare Match A
                 .equ   OC1Baddr        = 0x000c        ; Timer/Counter1 Compare Match B
                 .equ   OVF1addr        = 0x000d        ; Timer/Counter1 Overflow
                 .equ   OC0Aaddr        = 0x000e        ; TimerCounter0 Compare Match A
                 .equ   OC0Baddr        = 0x000f        ; TimerCounter0 Compare Match B
                 .equ   OVF0addr        = 0x0010        ; Timer/Couner0 Overflow
                 .equ   SPIaddr = 0x0011        ; SPI Serial Transfer Complete
                 .equ   URXCaddr        = 0x0012        ; USART Rx Complete
                 .equ   UDREaddr        = 0x0013        ; USART, Data Register Empty
                 .equ   UTXCaddr        = 0x0014        ; USART Tx Complete
                 .equ   ADCCaddr        = 0x0015        ; ADC Conversion Complete
                 .equ   ERDYaddr        = 0x0016        ; EEPROM Ready
                 .equ   ACIaddr = 0x0017        ; Analog Comparator
                 .equ   TWIaddr = 0x0018        ; Two-wire Serial Interface
                 .equ   SPMRaddr        = 0x0019        ; Store Program Memory Read
                 
                 .equ   INT_VECTORS_SIZE        = 26    ; size in words
                 
                 #endif  /* _M88DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 
                 
                 
                 ; Notes:
                 ; The status register can be accessed in the I/O memory space at $3F.
                 ; This test bench uses that to quickly check that all status register
                 ; bits are being See https://people.ece.cornell.edu/land/courses/ece4760/AtmelStuff/at90s4414.pdf
                 
                 ;.MACRO SETMEM ; Sets the memory at address @1 to be the byte @0.
                 ;   
                 ;.ENDMACRO
                 .MACRO ASSERT ; Assert byte @0 is the value stored at address @1.
                     PUSH r16
                     PUSH r17
                     LDS r16, @1
                     LDI r17, @0
                     CPSE  r17, r16    ; Compare and skip if equal
                     CALL test_failure ; If not equal, call test_failure, else return
                     POP r17  
                     POP r16
                 .ENDMACRO
                 
                 .MACRO CLR_SREG
                     BCLR 0
                     BCLR 1
                     BCLR 2
                     BCLR 3
                     BCLR 4
                     BCLR 5
                     BCLR 6
                     BCLR 7
                 .ENDMACRO
                 
                 
                 .EQU SREG_ADDR = $3F
                 
                 ; It seems that AVR Studio auto-defines these,
                 ; but if they weren't defined, they should have these values:
                 ;.EQU SREG_C = 0
                 ;.EQU SREG_Z = 1
                 ;.EQU SREG_N = 2
                 ;.EQU SREG_V = 3
                 ;.EQU SREG_S = 4
                 ;.EQU SREG_H = 5
                 ;.EQU SREG_T = 6
                 ;.EQU SREG_I = 7
                 
                 
                 .CSEG ; Start code segment
                 
                 ; TODO for better testing:
                 ; - Randomize some Status register flags to be 1 instead of 0,
                 ;   and then make sure that instructions don't modify
                 ;   flags they are supposed to leave untouched.
                 
                 
                 
                 ;PREPROCESS TestAdd {r16=Rd, r17=Rd, r18=Rd, X={X, Y, Z}}
                 start_test_add:
000000 9488
000001 9498
000002 94a8
000003 94b8
000004 94c8
000005 94d8
000006 94e8
000007 94f8          CLR_SREG
                 test_add_to_zero:
000008 e000          ldi r16, $00    ; 
000009 ea1f          ldi r17, $AF    ;
00000a 0f01          ADD r16, r17    ;
00000b b72f          IN  r18, $3F    ; Read the Status register
00000c e0b1          LDI r27, $01    ;
00000d e0a0          LDI r26, $00    ;
00000e 930c          ST  X,   r16    ;W AF 0100
00000f 931c          ST  X,   r17    ;W AF 0100
000010 932c          ST  X,   r18    ;W 14 0100
                 
                  test_add_of_zero:
000011 ea0f          ldi r16, $AF    ; 
000012 e010          ldi r17, $00    ;
000013 0f01          ADD r16, r17    ;
000014 b72f          IN  r18, $3F    ; Read the Status register
000015 e0b1          LDI r27, $01    ;
000016 e0a0          LDI r26, $00    ;
000017 930c          ST  X,   r16    ;W AF 0100
000018 931c          ST  X,   r17    ;W 00 0100
000019 932c          ST  X,   r18    ;W 14 0100
                 
                 test_add_overflow:
00001a eb00          ldi r16, $B0    ; 
00001b e81f          ldi r17, $8F    ;
00001c 0f01          ADD r16, r17    ; -- 176 + 143 = 319 = 63 mod 256, carry 1
00001d b72f          IN  r18, $3F    ; Read the Status register
00001e e0b1          LDI r27, $01    ;
00001f e0a0          LDI r26, $00    ;
000020 930c          ST  X,   r16    ;W 3F 0100
000021 931c          ST  X,   r17    ;W 8F 0100
000022 932c          ST  X,   r18    ;W 19 0100
                 
                 test_add_overflow_to_zero:
000023 e70f          ldi r16, $7F    ; 
000024 e811          ldi r17, $81    ;
000025 0f01          ADD r16, r17    ; -- 127 + 129 = 0 with carry 1
000026 b72f          IN  r18, $3F    ; Read the Status register
000027 e0b1          LDI r27, $01    ;
000028 e0a0          LDI r26, $00    ;
000029 930c          ST  X,   r16    ;W 00 0100
00002a 931c          ST  X,   r17    ;W 81 0100
00002b 932c          ST  X,   r18    ;W 23 0100
                 
                 test_add_zeros:
00002c e000          ldi r16, $00    ; 
00002d e010          ldi r17, $00    ;
00002e 0f01          ADD r16, r17    ; -- 176 + 143 = 319 = 63 mod 256, carry 1
00002f b72f          IN  r18, $3F    ; Read the Status register
000030 e0b1          LDI r27, $01    ;
000031 e0a0          LDI r26, $00    ;
000032 930c          ST  X,   r16    ;W 00 0100
000033 931c          ST  X,   r17    ;W 00 0100
000034 932c          ST  X,   r18    ;W 02 0100
                 
                 ;PREPROCESS TestADC
                 start_test_adc:
000035 9488
000036 9498
000037 94a8
000038 94b8
000039 94c8
00003a 94d8
00003b 94e8
00003c 94f8          CLR_SREG
                 test_adc_to_zero:
00003d 9488          BCLR SREG_C     ; Clear carry flag
00003e e000          ldi r16, $00    ; 
00003f ea1f          ldi r17, $AF    ;
000040 1f01          ADC r16, r17    ;
000041 b72f          IN  r18, $3F    ; Read the Status register
000042 e0b1          LDI r27, $01    ;
000043 e0a0          LDI r26, $00    ;
000044 930c          ST  X,   r16    ;W AF 0100
000045 931c          ST  X,   r17    ;W AF 0100
000046 932c          ST  X,   r18    ;W 14 0100
                 
                  test_adc_of_zero:
000047 9488          BCLR SREG_C     ; Clear carry flag
000048 ea0f          ldi r16, $AF    ; 
000049 e010          ldi r17, $00    ;
00004a 1f01          ADC r16, r17    ;
00004b b72f          IN  r18, $3F    ; Read the Status register
00004c e0b1          LDI r27, $01    ;
00004d e0a0          LDI r26, $00    ;
00004e 930c          ST  X,   r16    ;W AF 0100
00004f 931c          ST  X,   r17    ;W 00 0100
000050 932c          ST  X,   r18    ;W 14 0100
                 
                 test_adc_overflow:
000051 9488          BCLR SREG_C     ; Clear carry flag
000052 eb00          ldi r16, $B0    ; 
000053 e81f          ldi r17, $8F    ;
000054 1f01          ADC r16, r17    ; -- 176 + 143 = 319 = 63 mod 256, carry 1
000055 b72f          IN  r18, $3F    ; Read the Status register
000056 e0b1          LDI r27, $01    ;
000057 e0a0          LDI r26, $00    ;
000058 930c          ST  X,   r16    ;W 3F 0100
000059 931c          ST  X,   r17    ;W 8F 0100
00005a 932c          ST  X,   r18    ;W 19 0100
                 
                 test_adc_overflow_to_zero:
00005b 9488          BCLR SREG_C     ; Clear carry flag
00005c e70f          ldi r16, $7F    ; 
00005d e811          ldi r17, $81    ;
00005e 1f01          ADC r16, r17    ; -- 127 + 129 = 0 with carry 1
00005f b72f          IN  r18, $3F    ; Read the Status register
000060 e0b1          LDI r27, $01    ;
000061 e0a0          LDI r26, $00    ;
000062 930c          ST  X,   r16    ;W 00 0100
000063 931c          ST  X,   r17    ;W 81 0100
000064 932c          ST  X,   r18    ;W 23 0100
                 
                 test_adc_zeros:
000065 9488          BCLR SREG_C     ; Clear carry flag
000066 e000          ldi r16, $00    ; 
000067 e010          ldi r17, $00    ;
000068 1f01          ADC r16, r17    ; -- 176 + 143 = 319 = 63 mod 256, carry 1
000069 b72f          IN  r18, $3F    ; Read the Status register
00006a e0b1          LDI r27, $01    ;
00006b e0a0          LDI r26, $00    ;
00006c 930c          ST  X,   r16    ;W 00 0100
00006d 931c          ST  X,   r17    ;W 00 0100
00006e 932c          ST  X,   r18    ;W 02 0100
                 
                 ; Test adding all zeros with carry flag set
                 test_adc_with_carry_zeros:
00006f 9408          BSET SREG_C     ; Set carry flag
000070 e000          ldi r16, $00    ; 
000071 e010          ldi r17, $00    ;
000072 1f01          ADC r16, r17    ; -- 176 + 143 = 319 = 63 mod 256, carry 1
000073 b72f          IN  r18, $3F    ; Read the Status register
000074 e0b1          LDI r27, $01    ;
000075 e0a0          LDI r26, $00    ;
000076 930c          ST  X,   r16    ;W 01 0100
000077 931c          ST  X,   r17    ;W 00 0100
000078 932c          ST  X,   r18    ;W 00 0100
                 
                 ; Test adding numbers that add to one with carry set
                 test_adc_with_carry_overflow_to_one:
000079 9408          BSET SREG_C     ; Clear carry flag
00007a e70f          ldi r16, $7F    ; 
00007b e811          ldi r17, $81    ;
00007c 1f01          ADC r16, r17    ; -- 127 + 129 = 0 with carry 1
00007d b72f          IN  r18, $3F    ; Read the Status register
00007e e0b1          LDI r27, $01    ;
00007f e0a0          LDI r26, $00    ;
000080 930c          ST  X,   r16    ;W 01 0100
000081 931c          ST  X,   r17    ;W 81 0100
000082 932c          ST  X,   r18    ;W 21 0100
                 
                 ; Test adding numbers that add to zero with carry set
                 test_adc_with_carry_overflow_to_zero:
000083 9408          BSET SREG_C     ; Clear carry flag
000084 e70e          ldi r16, $7E    ; 
000085 e811          ldi r17, $81    ;
000086 1f01          ADC r16, r17    ; -- 127 + 129 = 0 with carry 1
000087 b72f          IN  r18, $3F    ; Read the Status register
000088 e0b1          LDI r27, $01    ;
000089 e0a0          LDI r26, $00    ;
00008a 930c          ST  X,   r16    ;W 00 0100
00008b 931c          ST  X,   r17    ;W 81 0100
00008c 932c          ST  X,   r18    ;W 23 0100
                 
                 ;PREPROCESS TestADIW
                 ; ADIW Instruction: 
                 ; Adds an immediate value (0-63) to a register pair and places the result in the register pair.
                 ; 
                 
                 start_test_adiw:
00008d 9488
00008e 9498
00008f 94a8
000090 94b8
000091 94c8
000092 94d8
000093 94e8
000094 94f8          CLR_SREG
                 
                 test_adiw_zero:
000095 94d8          BCLR SREG_H       ; Explicitly make clear H flag is clear, even though done above.
000096 e080          LDI r24, $00
000097 e090          LDI r25, $00
000098 9600          ADIW r25:r24, 0
000099 b72f          IN  r18, $3F      ; Read the Status register
00009a 9390 0101     STS $0101, r25    ;W 00 0101
00009c 9380 0100     STS $0100, r24    ;W 00 0100
00009e 9320 0100     STS $0100, r18    ;W 02 0100
                 
                 test_adiw_notouch_hflag:
                     ; Same test as above, but set the H flag before
0000a0 9458          BSET SREG_H
0000a1 e080          LDI r24, $00
0000a2 e090          LDI r25, $00
0000a3 9600          ADIW r25:r24, 0
0000a4 b72f          IN  r18, $3F      ; Read the Status register
0000a5 9390 0101     STS $0101, r25    ;W 00 0101
0000a7 9380 0100     STS $0100, r24    ;W 00 0100
0000a9 9320 0100     STS $0100, r18    ;W 22 0100
                 
                 test_adiw_halfcarry_no_effect:
0000ab 94d8          BCLR SREG_H
0000ac e08f          LDI r24, $0F
0000ad e090          LDI r25, $00
0000ae 9601          ADIW r25:r24, 1
0000af b72f          IN  r18, $3F      ; Read the Status register
0000b0 9390 0101     STS $0101, r25    ;W 00 0101
0000b2 9380 0100     STS $0100, r24    ;W 10 0100
0000b4 9320 0100     STS $0100, r18    ;W 00 0100
                 
                 test_adiw_lowcarry:
0000b6 ef8f          LDI r24, $FF
0000b7 e090          LDI r25, $00
0000b8 9601          ADIW r25:r24, 1
0000b9 b72f          IN  r18, $3F      ; Read the Status register
0000ba 9390 0101     STS $0101, r25    ;W 01 0101
0000bc 9380 0100     STS $0100, r24    ;W 00 0100
0000be 9320 0100     STS $0100, r18    ;W 00 0100
                 
                 test_adiw_typical:
0000c0 ee8b          LDI r24, 235
0000c1 e79f          LDI r25, 127
0000c2 9644          ADIW r25:r24, 20  ; 127*256 + 235 + 20 = 127*256 + 255
0000c3 b72f          IN  r18, $3F      ; Read the Status register
0000c4 9390 0101     STS $0101, r25    ;W 7F 0101
0000c6 9380 0100     STS $0100, r24    ;W FF 0100
0000c8 9320 0100     STS $0100, r18    ;W 00 0100
                 
                 test_adiw_signed_overflow:
0000ca ee8d          LDI r24, 237
0000cb e79f          LDI r25, 127
0000cc 9681          ADIW r25:r24, 33  ; 127*256 + 237 + 33 = 128*256 + 14
0000cd b72f          IN  r18, $3F      ; Read the Status register
0000ce 9390 0101     STS $0101, r25    ;W 80 0101
0000d0 9380 0100     STS $0100, r24    ;W 0E 0100
0000d2 9320 0100     STS $0100, r18    ;W 0C 0100
                 
                 test_adiw_unsigned_overflow:
0000d4 ec83          LDI r24, 195
0000d5 ef9f          LDI r25, 255
0000d6 96cf          ADIW r25:r24, 63  ; 255*256 + 195 + 63 = 1*65536 + 0*256 + 2
0000d7 b72f          IN  r18, $3F      ; Read the Status register
0000d8 9390 0101     STS $0101, r25    ;W 00 0101
0000da 9380 0100     STS $0100, r24    ;W 02 0100
0000dc 9320 0100     STS $0100, r18    ;W 01 0100
                 
                 test_adiw_unsigned_overflow_to_zero:
0000de ec8e          LDI r24, 206
0000df ef9f          LDI r25, 255
0000e0 96c2          ADIW r25:r24, 50  ; 255*256 + 206 + 50 = 1*65536 + 0*256 + 0
0000e1 b72f          IN  r18, $3F      ; Read the Status register
0000e2 9390 0101     STS $0101, r25    ;W 00 0101
0000e4 9380 0100     STS $0100, r24    ;W 00 0100
0000e6 9320 0100     STS $0100, r18    ;W 03 0100
                 
                 ;PREPROCESS TestAND
                 start_test_and:
0000e8 9488
0000e9 9498
0000ea 94a8
0000eb 94b8
0000ec 94c8
0000ed 94d8
0000ee 94e8
0000ef 94f8          CLR_SREG
                 
                 test_and_with_zero:
0000f0 ef41          LDI r20, $F1
0000f1 e050          LDI r21, $00
0000f2 2354          AND r21, r20
0000f3 b72f          IN  r18, $3F      ; Read the Status register
0000f4 9340 0100     STS $0100, r20    ;W F1 0100
0000f6 9350 0100     STS $0100, r21    ;W 00 0100
0000f8 9320 0100     STS $0100, r18    ;W 02 0100
                 
                 test_and_result_zero:
0000fa 9438          BSET SREG_V       ; AND should clear V flag always
0000fb ea49          LDI r20, $A9
0000fc e456          LDI r21, $46
0000fd 2354          AND r21, r20
0000fe b72f          IN  r18, $3F      ; Read the Status register
0000ff 9340 0100     STS $0100, r20    ;W A9 0100
000101 9350 0100     STS $0100, r21    ;W 00 0100
000103 9320 0100     STS $0100, r18    ;W 02 0100
                 
                 test_and_n_flag:
000105 9438          BSET SREG_V       ; AND should clear V flag always
000106 ef49          LDI r20, $F9
000107 e855          LDI r21, $85
000108 2354          AND r21, r20
000109 b72f          IN  r18, $3F      ; Read the Status register
00010a 9340 0100     STS $0100, r20    ;W F9 0100
00010c 9350 0100     STS $0100, r21    ;W 81 0100
00010e 9320 0100     STS $0100, r18    ;W 14 0100
                 
                 ;PREPROCESS TestANDI
                 start_test_andi:
000110 9488
000111 9498
000112 94a8
000113 94b8
000114 94c8
000115 94d8
000116 94e8
000117 94f8          CLR_SREG
                 
                 test_andi_with_zero:
000118 e050          LDI r21, $00
000119 7f51          ANDI r21, $F1
00011a b72f          IN  r18, $3F      ; Read the Status register
00011b 9350 0100     STS $0100, r21    ;W 00 0100
00011d 9320 0100     STS $0100, r18    ;W 02 0100
                 
                 test_andi_result_zero:
00011f 9438          BSET SREG_V       ; AND should clear V flag always
000120 e456          LDI r21, $46
000121 7a59          ANDI r21, $A9
000122 b72f          IN  r18, $3F      ; Read the Status register
000123 9350 0100     STS $0100, r21    ;W 00 0100
000125 9320 0100     STS $0100, r18    ;W 02 0100
                 
                 test_andi_n_flag:
000127 9438          BSET SREG_V       ; AND should clear V flag always
000128 e855          LDI r21, $85
000129 7f59          ANDI r21, $F9
00012a b72f          IN  r18, $3F      ; Read the Status register
00012b 9350 0100     STS $0100, r21    ;W 81 0100
00012d 9320 0100     STS $0100, r18    ;W 14 0100
                 
                 ;PREPROCESS TestASR
                 start_test_asr:
00012f 9488
000130 9498
000131 94a8
000132 94b8
000133 94c8
000134 94d8
000135 94e8
000136 94f8          CLR_SREG
                 
                 test_asr_high_zero:
000137 e60a          LDI r16, $6A
000138 2e30          MOV r3, r16
                     ; Now, do 8 shifts and check the results regularly.
000139 9435          ASR r3
00013a b72f          IN  r18, $3F      ; Read the Status register
00013b 9230 0100     STS $0100, r3    ;W 35 0100
00013d 9320 0100     STS $0100, r18    ;W 00 0100
                 
00013f 9435          ASR r3
000140 b72f          IN  r18, $3F      ; Read the Status register
000141 9230 0100     STS $0100, r3    ;W 1A 0100
000143 9320 0100     STS $0100, r18    ;W 19 0100
                 
000145 9435          ASR r3
000146 b72f          IN  r18, $3F      ; Read the Status register
000147 9230 0100     STS $0100, r3    ;W 0D 0100
000149 9320 0100     STS $0100, r18    ;W 00 0100
                 
00014b 9435          ASR r3
00014c b72f          IN  r18, $3F      ; Read the Status register
00014d 9230 0100     STS $0100, r3    ;W 06 0100
00014f 9320 0100     STS $0100, r18    ;W 19 0100
                 
                     ; Shift twice in a row
000151 9435          ASR r3
000152 9435          ASR r3
000153 b72f          IN  r18, $3F      ; Read the Status register
000154 9230 0100     STS $0100, r3    ;W 01 0100
000156 9320 0100     STS $0100, r18    ;W 19 0100
                 
                     ; Shift to zero
000158 9435          ASR r3
000159 b72f          IN  r18, $3F      ; Read the Status register
00015a 9230 0100     STS $0100, r3    ;W 00 0100
00015c 9320 0100     STS $0100, r18    ;W 1B 0100
                 
                     ; Shift at zero
00015e 9435          ASR r3
00015f b72f          IN  r18, $3F      ; Read the Status register
000160 9230 0100     STS $0100, r3    ;W 00 0100
000162 9320 0100     STS $0100, r18    ;W 02 0100
                 
                 
                 test_asr_high_one:
000164 e804          LDI r16, $84
000165 2e30          MOV r3, r16
                     ; Now, do 8 shifts and check the results regularly.
000166 9435          ASR r3
000167 b72f          IN  r18, $3F      ; Read the Status register
000168 9230 0100     STS $0100, r3    ;W C2 0100
00016a 9320 0100     STS $0100, r18    ;W 0C 0100
                 
00016c 9435          ASR r3
00016d b72f          IN  r18, $3F      ; Read the Status register
00016e 9230 0100     STS $0100, r3    ;W E1 0100
000170 9320 0100     STS $0100, r18    ;W 0C 0100
                 
000172 9435          ASR r3
000173 b72f          IN  r18, $3F      ; Read the Status register
000174 9230 0100     STS $0100, r3    ;W F0 0100
000176 9320 0100     STS $0100, r18    ;W 15 0100
                 
000178 9435          ASR r3
000179 b72f          IN  r18, $3F      ; Read the Status register
00017a 9230 0100     STS $0100, r3     ;W F8 0100
00017c 9320 0100     STS $0100, r18    ;W 0C 0100
                 
                     ; Shift twice in a row
00017e 9435          ASR r3
00017f 9435          ASR r3
000180 b72f          IN  r18, $3F      ; Read the Status register
000181 9230 0100     STS $0100, r3    ;W FE 0100
000183 9320 0100     STS $0100, r18    ;W 0C 0100
                 
                     ; Shift to zero
000185 9435          ASR r3
000186 b72f          IN  r18, $3F      ; Read the Status register
000187 9230 0100     STS $0100, r3    ;W FF 0100
000189 9320 0100     STS $0100, r18    ;W 0C 0100
                 
                     ; Shift at zero
00018b 9435          ASR r3
00018c b72f          IN  r18, $3F      ; Read the Status register
00018d 9230 0100     STS $0100, r3    ;W FF 0100
00018f 9320 0100     STS $0100, r18    ;W 15 0100
                 
                 ;PREPROCESS TestBCLR
                 start_bclr:
000191 9488
000192 9498
000193 94a8
000194 94b8
000195 94c8
000196 94d8
000197 94e8
000198 94f8          CLR_SREG
                 
                 
                 test_bclr:
                     ; Go in non-sequential order, clearing bits one-by-one
000199 ef0f          LDI r16, $FF
00019a bf0f          OUT SREG_ADDR, r16
                 
                     ; Clear V -- bit 3
00019b 94b8          BCLR SREG_V
00019c b72f          IN  r18, SREG_ADDR  ; Read the Status register
00019d 9320 0100     STS $0100, r18      ;W F7 0100
                 
                     ; Clear H -- bit 5
00019f 94d8          BCLR SREG_H
0001a0 b72f          IN  r18, SREG_ADDR  ; Read the Status register
0001a1 9320 0100     STS $0100, r18      ;W D7 0100
                 
                     ; Clear T -- bit 6
0001a3 94e8          BCLR SREG_T
0001a4 b72f          IN  r18, SREG_ADDR  ; Read the Status register
0001a5 9320 0100     STS $0100, r18      ;W 97 0100
                 
                     ; Clear Z -- bit 1
0001a7 9498          BCLR SREG_Z
0001a8 b72f          IN  r18, SREG_ADDR  ; Read the Status register
0001a9 9320 0100     STS $0100, r18      ;W 95 0100
                 
                     ; Clear N -- bit 2
0001ab 94a8          BCLR SREG_N
0001ac b72f          IN  r18, SREG_ADDR  ; Read the Status register
0001ad 9320 0100     STS $0100, r18      ;W 91 0100
                 
                     ; Clear C -- bit 0
0001af 9488          BCLR SREG_C
0001b0 b72f          IN  r18, SREG_ADDR  ; Read the Status register
0001b1 9320 0100     STS $0100, r18      ;W 90 0100
                 
                     ; Clear I -- bit 7
0001b3 94f8          BCLR SREG_I
0001b4 b72f          IN  r18, SREG_ADDR  ; Read the Status register
0001b5 9320 0100     STS $0100, r18      ;W 10 0100
                 
                     ; Clear S -- bit 4
0001b7 94c8          BCLR SREG_S
0001b8 b72f          IN  r18, SREG_ADDR  ; Read the Status register
0001b9 9320 0100     STS $0100, r18      ;W 00 0100
                 
                 ;PREPROCESS TestBLD
                 start_bld:
0001bb 9488
0001bc 9498
0001bd 94a8
0001be 94b8
0001bf 94c8
0001c0 94d8
0001c1 94e8
0001c2 94f8          CLR_SREG
                 test_bld:
                     ; Go through and write 1s and 0s from T flag to reg
                     ; Start with target bit as bit 0
0001c3 e010          LDI r17, $00
0001c4 94e8          BCLR SREG_T
0001c5 f910          BLD r17, 0          ; Write 0 to target bit
0001c6 9310 0100     STS $0100, r17      ;W 00 0100
0001c8 9468          BSET SREG_T         ; Set the T bit
0001c9 f910          BLD r17, 0          ; Write 1 to target bit
0001ca 9310 0100     STS $0100, r17      ;W 01 0100
0001cc f910          BLD r17, 0          ; Write 1 again to make sure no toggle
0001cd 9310 0100     STS $0100, r17      ;W 01 0100
                 
                     ; Now, we repeat the above for bits 1-7
                 
                     ; Target bit 1
0001cf e010          LDI r17, $00
0001d0 94e8          BCLR SREG_T
0001d1 f911          BLD r17, 1          ; Write 0 to target bit
0001d2 9310 0100     STS $0100, r17      ;W 00 0100
0001d4 9468          BSET SREG_T         ; Set the T bit
0001d5 f911          BLD r17, 1          ; Write 1 to target bit
0001d6 9310 0100     STS $0100, r17      ;W 02 0100
0001d8 f911          BLD r17, 1          ; Write 1 again to make sure no toggle
0001d9 9310 0100     STS $0100, r17      ;W 02 0100
                 
                     ; Target bit 2
0001db e010          LDI r17, $00
0001dc 94e8          BCLR SREG_T
0001dd f912          BLD r17, 2          ; Write 0 to target bit
0001de 9310 0100     STS $0100, r17      ;W 00 0100
0001e0 9468          BSET SREG_T         ; Set the T bit
0001e1 f912          BLD r17, 2          ; Write 1 to target bit
0001e2 9310 0100     STS $0100, r17      ;W 04 0100
0001e4 f912          BLD r17, 2          ; Write 1 again to make sure no toggle
0001e5 9310 0100     STS $0100, r17      ;W 04 0100
                 
                     ; Target bit 3
0001e7 e010          LDI r17, $00
0001e8 94e8          BCLR SREG_T
0001e9 f913          BLD r17, 3          ; Write 0 to target bit
0001ea 9310 0100     STS $0100, r17      ;W 00 0100
0001ec 9468          BSET SREG_T         ; Set the T bit
0001ed f913          BLD r17, 3          ; Write 1 to target bit
0001ee 9310 0100     STS $0100, r17      ;W 08 0100
0001f0 f913          BLD r17, 3          ; Write 1 again to make sure no toggle
0001f1 9310 0100     STS $0100, r17      ;W 08 0100
                 
                     ; Target bit 4
0001f3 e010          LDI r17, $00
0001f4 94e8          BCLR SREG_T
0001f5 f914          BLD r17, 4          ; Write 0 to target bit
0001f6 9310 0100     STS $0100, r17      ;W 00 0100
0001f8 9468          BSET SREG_T         ; Set the T bit
0001f9 f914          BLD r17, 4          ; Write 1 to target bit
0001fa 9310 0100     STS $0100, r17      ;W 10 0100
0001fc f914          BLD r17, 4          ; Write 1 again to make sure no toggle
0001fd 9310 0100     STS $0100, r17      ;W 10 0100
                 
                     ; Target bit 5
0001ff e010          LDI r17, $00
000200 94e8          BCLR SREG_T
000201 f915          BLD r17, 5          ; Write 0 to target bit
000202 9310 0100     STS $0100, r17      ;W 00 0100
000204 9468          BSET SREG_T         ; Set the T bit
000205 f915          BLD r17, 5          ; Write 1 to target bit
000206 9310 0100     STS $0100, r17      ;W 20 0100
000208 f915          BLD r17, 5          ; Write 1 again to make sure no toggle
000209 9310 0100     STS $0100, r17      ;W 20 0100
                 
                     ; Target bit 6
00020b e010          LDI r17, $00
00020c 94e8          BCLR SREG_T
00020d f916          BLD r17, 6          ; Write 0 to target bit
00020e 9310 0100     STS $0100, r17      ;W 00 0100
000210 9468          BSET SREG_T         ; Set the T bit
000211 f916          BLD r17, 6          ; Write 1 to target bit
000212 9310 0100     STS $0100, r17      ;W 40 0100
000214 f916          BLD r17, 6          ; Write 1 again to make sure no toggle
000215 9310 0100     STS $0100, r17      ;W 40 0100
                 
                     ; Target bit 7
000217 e010          LDI r17, $00
000218 94e8          BCLR SREG_T
000219 f917          BLD r17, 7          ; Write 0 to target bit
00021a 9310 0100     STS $0100, r17      ;W 00 0100
00021c 9468          BSET SREG_T         ; Set the T bit
00021d f917          BLD r17, 7          ; Write 1 to target bit
00021e 9310 0100     STS $0100, r17      ;W 80 0100
000220 f917          BLD r17, 7          ; Write 1 again to make sure no toggle
000221 9310 0100     STS $0100, r17      ;W 80 0100
                 
                 ;PREPROCESS TestBSET
                 
                 ; This implements testing for both BSET and BCLR
                 start_bset:
000223 9488
000224 9498
000225 94a8
000226 94b8
000227 94c8
000228 94d8
000229 94e8
00022a 94f8          CLR_SREG
                 test_bset:
                     ; Go in non-sequential order, setting bits one-by-one
00022b e000          LDI r16, $00
00022c bf0f          OUT SREG_ADDR, r16
                 
                     ; Clear V -- bit 3
00022d 9438          BSET SREG_V
00022e b72f          IN  r18, SREG_ADDR  ; Read the Status register
00022f 9320 0100     STS $0100, r18      ;W 08 0100
                 
                     ; Clear H -- bit 5
000231 9458          BSET SREG_H
000232 b72f          IN  r18, SREG_ADDR  ; Read the Status register
000233 9320 0100     STS $0100, r18      ;W 28 0100
                 
                     ; Clear T -- bit 6
000235 9468          BSET SREG_T
000236 b72f          IN  r18, SREG_ADDR  ; Read the Status register
000237 9320 0100     STS $0100, r18      ;W 68 0100
                 
                     ; Clear Z -- bit 1
000239 9418          BSET SREG_Z
00023a b72f          IN  r18, SREG_ADDR  ; Read the Status register
00023b 9320 0100     STS $0100, r18      ;W 6A 0100
                 
                     ; Clear N -- bit 2
00023d 9428          BSET SREG_N
00023e b72f          IN  r18, SREG_ADDR  ; Read the Status register
00023f 9320 0100     STS $0100, r18      ;W 6E 0100
                 
                     ; Clear C -- bit 0
000241 9408          BSET SREG_C
000242 b72f          IN  r18, SREG_ADDR  ; Read the Status register
000243 9320 0100     STS $0100, r18      ;W 6F 0100
                 
                     ; Clear I -- bit 7
000245 9478          BSET SREG_I
000246 b72f          IN  r18, SREG_ADDR  ; Read the Status register
000247 9320 0100     STS $0100, r18      ;W EF 0100
                 
                     ; Clear S -- bit 4
000249 9448          BSET SREG_S
00024a b72f          IN  r18, SREG_ADDR  ; Read the Status register
00024b 9320 0100     STS $0100, r18      ;W FF 0100
                 
                 ;PREPROCESS TestBST
                 start_bst:
00024d 9488
00024e 9498
00024f 94a8
000250 94b8
000251 94c8
000252 94d8
000253 94e8
000254 94f8          CLR_SREG
                 
                 test_bst:
                     ; Go through and read 1s and 0s into T flag
000255 e041          LDI r20, $01
000256 94e8          BCLR SREG_T
000257 fb41          BST r20, 1          ; Zero bit read in
000258 b72f          IN  r18, SREG_ADDR  ; Read the Status register
000259 9320 0100     STS $0100, r18      ;W 00 0100
00025b fb40          BST r20, 0          ; One bit read in
00025c b72f          IN  r18, SREG_ADDR  ; Read the Status register
00025d 9320 0100     STS $0100, r18      ;W 40 0100
00025f 9340 0100     STS $0100, r20      ;W 01 0100
                 
000261 e042          LDI r20, $02
000262 94e8          BCLR SREG_T
000263 fb40          BST r20, 0          ; Zero bit read in
000264 b72f          IN  r18, SREG_ADDR  ; Read the Status register
000265 9320 0100     STS $0100, r18      ;W 00 0100
000267 fb41          BST r20, 1
000268 b72f          IN  r18, SREG_ADDR  ; Read the Status register
000269 9320 0100     STS $0100, r18      ;W 40 0100
00026b 9340 0100     STS $0100, r20      ;W 02 0100
                 
00026d e044          LDI r20, $04
00026e 94e8          BCLR SREG_T
00026f fb47          BST r20, 7          ; Zero bit read in
000270 b72f          IN  r18, SREG_ADDR  ; Read the Status register
000271 9320 0100     STS $0100, r18      ;W 00 0100
000273 fb42          BST r20, 2
000274 b72f          IN  r18, SREG_ADDR  ; Read the Status register
000275 9320 0100     STS $0100, r18      ;W 40 0100
000277 9340 0100     STS $0100, r20      ;W 04 0100
                 
000279 e048          LDI r20, $08
00027a 94e8          BCLR SREG_T
00027b fb46          BST r20, 6          ; Zero bit read in
00027c b72f          IN  r18, SREG_ADDR  ; Read the Status register
00027d 9320 0100     STS $0100, r18      ;W 00 0100
00027f fb43          BST r20, 3
000280 b72f          IN  r18, SREG_ADDR  ; Read the Status register
000281 9320 0100     STS $0100, r18      ;W 40 0100
000283 9340 0100     STS $0100, r20      ;W 08 0100
                 
000285 e140          LDI r20, $10
000286 94e8          BCLR SREG_T
000287 fb45          BST r20, 5          ; Zero bit read in
000288 b72f          IN  r18, SREG_ADDR  ; Read the Status register
000289 9320 0100     STS $0100, r18      ;W 00 0100
00028b fb44          BST r20, 4
00028c b72f          IN  r18, SREG_ADDR  ; Read the Status register
00028d 9320 0100     STS $0100, r18      ;W 40 0100
00028f 9340 0100     STS $0100, r20      ;W 10 0100
                 
000291 e240          LDI r20, $20
000292 94e8          BCLR SREG_T
000293 fb44          BST r20, 4          ; Zero bit read in
000294 b72f          IN  r18, SREG_ADDR  ; Read the Status register
000295 9320 0100     STS $0100, r18      ;W 00 0100
000297 fb45          BST r20, 5
000298 b72f          IN  r18, SREG_ADDR  ; Read the Status register
000299 9320 0100     STS $0100, r18      ;W 40 0100
00029b 9340 0100     STS $0100, r20      ;W 20 0100
                 
00029d e440          LDI r20, $40
00029e 94e8          BCLR SREG_T
00029f fb43          BST r20, 3          ; Zero bit read in
0002a0 b72f          IN  r18, SREG_ADDR  ; Read the Status register
0002a1 9320 0100     STS $0100, r18      ;W 00 0100
0002a3 fb46          BST r20, 6
0002a4 b72f          IN  r18, SREG_ADDR  ; Read the Status register
0002a5 9320 0100     STS $0100, r18      ;W 40 0100
0002a7 9340 0100     STS $0100, r20      ;W 40 0100
                 
0002a9 e840          LDI r20, $80
0002aa 94e8          BCLR SREG_T
0002ab fb42          BST r20, 2          ; Zero bit read in
0002ac b72f          IN  r18, SREG_ADDR  ; Read the Status register
0002ad 9320 0100     STS $0100, r18      ;W 00 0100
0002af fb47          BST r20, 7
0002b0 b72f          IN  r18, SREG_ADDR  ; Read the Status register
0002b1 9320 0100     STS $0100, r18      ;W 40 0100
0002b3 9340 0100     STS $0100, r20      ;W 80 0100
                 
                 ;PREPROCESS TestCOM
                 start_com:
0002b5 9488
0002b6 9498
0002b7 94a8
0002b8 94b8
0002b9 94c8
0002ba 94d8
0002bb 94e8
0002bc 94f8          CLR_SREG
                 
                 ; All of the following tests for COM start with
                 ; a value, check complement, and then take complement
                 ; back to original value, check that.
                 test_com_zero:
0002bd e060          LDI r22, $00        ;
0002be 2e66          MOV r6, r22
0002bf 9460          COM r6
                     ; Check result
0002c0 b72f          IN  r18, SREG_ADDR  ; Read the Status register
0002c1 9260 0100     STS $0100, r6       ;W FF 0100
0002c3 9320 0100     STS $0100, r18      ;W 15 0100
                     ; Complement back to original value
0002c5 9460          COM r6
0002c6 b72f          IN  r18, SREG_ADDR  ; Read the Status register
0002c7 9260 0100     STS $0100, r6       ;W 00 0100
0002c9 9320 0100     STS $0100, r18      ;W 03 0100
                 
                 test_com_one:
0002cb e061          LDI r22, $01        ;
0002cc 2e66          MOV r6, r22
0002cd 9460          COM r6
                     ; Check result
0002ce b72f          IN  r18, SREG_ADDR  ; Read the Status register
0002cf 9260 0100     STS $0100, r6       ;W FE 0100
0002d1 9320 0100     STS $0100, r18      ;W 15 0100
                     ; Complement back to original value
0002d3 9460          COM r6
0002d4 b72f          IN  r18, SREG_ADDR  ; Read the Status register
0002d5 9260 0100     STS $0100, r6       ;W 01 0100
0002d7 9320 0100     STS $0100, r18      ;W 01 0100
                 
                 test_com_other:
0002d9 e664          LDI r22, $64        ; Value is 100
0002da 2e66          MOV r6, r22
0002db 9460          COM r6
                     ; Check result
0002dc b72f          IN  r18, SREG_ADDR  ; Read the Status register
0002dd 9260 0100     STS $0100, r6       ;W 9B 0100
0002df 9320 0100     STS $0100, r18      ;W 15 0100
                     ; Complement back to original value
0002e1 9460          COM r6
0002e2 b72f          IN  r18, SREG_ADDR  ; Read the Status register
0002e3 9260 0100     STS $0100, r6       ;W 64 0100
0002e5 9320 0100     STS $0100, r18      ;W 01 0100
                 
                 ;PREPROCESS TestCP
                 start_cp:
0002e7 9488
0002e8 9498
0002e9 94a8
0002ea 94b8
0002eb 94c8
0002ec 94d8
0002ed 94e8
0002ee 94f8          CLR_SREG
                 test_cp_no_mutate:
0002ef e860          LDI r22, $80
0002f0 2e46          MOV r4, r22
0002f1 ea75          LDI r23, $A5
0002f2 2e77          MOV r7, r23
0002f3 1447          CP r4, r7
                 
0002f4 9240 0100     STS $0100, r4       ;W 80 0100
0002f6 9270 0100     STS $0100, r7       ;W A5 0100
                 
                 test_cp_greater:
0002f8 ec68          LDI r22, $C8
0002f9 2e46          MOV r4, r22
0002fa e476          LDI r23, $46
0002fb 2e77          MOV r7, r23
0002fc 1447          CP r4, r7           ; Compare 200 - 70
                 
0002fd b72f          IN  r18, SREG_ADDR  ; Read the Status register
0002fe 9320 0100     STS $0100, r18      ;W 14 0100
                 
                 test_cp_less:
000300 e06a          LDI r22, $0A
000301 2e46          MOV r4, r22
000302 e77f          LDI r23, $7F
000303 2e77          MOV r7, r23
000304 1447          CP r4, r7           ; Compare 10 - 127
                 
000305 b72f          IN  r18, SREG_ADDR  ; Read the Status register
000306 9320 0100     STS $0100, r18      ;W 35 0100
                 
                 test_cp_equal:
000308 e16f          LDI r22, $1F
000309 2e46          MOV r4, r22
00030a e17f          LDI r23, $1F
00030b 2e77          MOV r7, r23
00030c 1447          CP r4, r7           ; Compare 31 - 31
                 
00030d b72f          IN  r18, SREG_ADDR  ; Read the Status register
00030e 9320 0100     STS $0100, r18      ;W 02 0100
                 
                 ;PREPROCESS TestCPC
                 start_cpc:
000310 9488
000311 9498
000312 94a8
000313 94b8
000314 94c8
000315 94d8
000316 94e8
000317 94f8          CLR_SREG
                 
                 test_cpc_no_carry_equal:
000318 9488          BCLR SREG_C
000319 9418          BSET SREG_Z
00031a e33f          LDI r19, $3F
00031b e34f          LDI r20, $3F
00031c 0734          CPC r19, r20
00031d b72f          IN  r18, SREG_ADDR  ; Read the Status register
00031e 9320 0100     STS $0100, r18      ;W 02 0100
                 
                 test_cpc_no_carry_not_equal:
000320 9488          BCLR SREG_C
000321 9418          BSET SREG_Z
000322 e430          LDI r19, $40
000323 e34f          LDI r20, $3F
000324 0734          CPC r19, r20
000325 b72f          IN  r18, SREG_ADDR  ; Read the Status register
000326 9320 0100     STS $0100, r18      ;W 20 0100
                 
                 test_cpc_carry_equal:
000328 9408          BSET SREG_C
000329 9418          BSET SREG_Z
00032a e430          LDI r19, $40
00032b e34f          LDI r20, $3F
00032c 0734          CPC r19, r20
00032d b72f          IN  r18, SREG_ADDR  ; Read the Status register
00032e 9320 0100     STS $0100, r18      ;W 22 0100
                 
                 test_cpc_carry_not_equal:
000330 9408          BSET SREG_C
000331 9418          BSET SREG_Z
000332 e33f          LDI r19, $3F
000333 e34f          LDI r20, $3F
000334 0734          CPC r19, r20
000335 b72f          IN  r18, SREG_ADDR  ; Read the Status register
000336 9320 0100     STS $0100, r18      ;W 35 0100
                 
                 ;PREPROCESS TestCPI
                 
                 ; Similar test sequence to CP instruction
                 start_cpi:
000338 9488
000339 9498
00033a 94a8
00033b 94b8
00033c 94c8
00033d 94d8
00033e 94e8
00033f 94f8          CLR_SREG
                 test_cpi_no_mutate:
000340 e880          LDI r24, $80
000341 3a85          CPI r24, $A5
                 
000342 9380 0100     STS $0100, r24       ;W 80 0100
                 
                 test_cpi_greater:
000344 ec88          LDI r24, $C8
000345 3486          CPI r24, $46           ; Compare 200 - 70
                 
000346 b72f          IN  r18, SREG_ADDR  ; Read the Status register
000347 9320 0100     STS $0100, r18      ;W 14 0100
                 
                 test_cpi_less:
000349 e08a          LDI r24, $0A
00034a 378f          CPI r24, $7F           ; Compare 10 - 127
                 
00034b b72f          IN  r18, SREG_ADDR  ; Read the Status register
00034c 9320 0100     STS $0100, r18      ;W 35 0100
                 
                 test_cpi_equal:
00034e e18f          LDI r24, $1F
00034f 318f          CPI r24, $1F           ; Compare 31 - 31
                 
000350 b72f          IN  r18, SREG_ADDR  ; Read the Status register
000351 9320 0100     STS $0100, r18      ;W 02 0100
                 ;PREPROCESS TestDEC
                 start_dec:
000353 9488
000354 9498
000355 94a8
000356 94b8
000357 94c8
000358 94d8
000359 94e8
00035a 94f8          CLR_SREG
                 test_dec_positive:
00035b e0b2          LDI r27, $02        ; Initialize to 2
                 
00035c 95ba          DEC r27
00035d b72f          IN  r18, SREG_ADDR  ; Read the Status register
00035e 9320 0100     STS $0100, r18      ;W 00 0100
000360 93b0 0100     STS $0100, r27      ;W 01 0100
                 
000362 95ba          DEC r27
000363 b72f          IN  r18, SREG_ADDR  ; Read the Status register
000364 9320 0100     STS $0100, r18      ;W 02 0100
000366 93b0 0100     STS $0100, r27      ;W 00 0100
                 
000368 95ba          DEC r27
000369 b72f          IN  r18, SREG_ADDR  ; Read the Status register
00036a 9320 0100     STS $0100, r18      ;W 14 0100
00036c 93b0 0100     STS $0100, r27      ;W FF 0100
                 
00036e 95ba          DEC r27
00036f b72f          IN  r18, SREG_ADDR  ; Read the Status register
000370 9320 0100     STS $0100, r18      ;W 14 0100
000372 93b0 0100     STS $0100, r27      ;W FE 0100
                 
                 test_dec_negative:
000374 e8b1          LDI r27, $81        ; Initialize to -127
                 
000375 95ba          DEC r27
000376 b72f          IN  r18, SREG_ADDR  ; Read the Status register
000377 9320 0100     STS $0100, r18      ;W 14 0100
000379 93b0 0100     STS $0100, r27      ;W 80 0100
                 
00037b 95ba          DEC r27
00037c b72f          IN  r18, SREG_ADDR  ; Read the Status register
00037d 9320 0100     STS $0100, r18      ;W 18 0100
00037f 93b0 0100     STS $0100, r27      ;W 7F 0100
                 
000381 95ba          DEC r27
000382 b72f          IN  r18, SREG_ADDR  ; Read the Status register
000383 9320 0100     STS $0100, r18      ;W 00 0100
000385 93b0 0100     STS $0100, r27      ;W 7E 0100
                 
                 ;PREPROCESS TestEOR
                 start_eor:
000387 9488
000388 9498
000389 94a8
00038a 94b8
00038b 94c8
00038c 94d8
00038d 94e8
00038e 94f8          CLR_SREG
                 test_eor_zeros:
00038f e040          LDI r20, $00
000390 e050          LDI r21, $00
                 
000391 2745          EOR r20, r21
                 
000392 b72f          IN  r18, SREG_ADDR  ; Read the Status register
000393 9320 0100     STS $0100, r18      ;W 02 0100
000395 9340 0100     STS $0100, r20      ;W 00 0100
000397 9350 0100     STS $0100, r21      ;W 00 0100
                 
                 test_eor_rr_ones:
000399 e040          LDI r20, $00
00039a ef5f          LDI r21, $FF
                 
00039b 2745          EOR r20, r21
                 
00039c b72f          IN  r18, SREG_ADDR  ; Read the Status register
00039d 9320 0100     STS $0100, r18      ;W 14 0100
00039f 9340 0100     STS $0100, r20      ;W FF 0100
0003a1 9350 0100     STS $0100, r21      ;W FF 0100
                 
                 test_eor_rd_ones:
0003a3 ef4f          LDI r20, $FF
0003a4 e050          LDI r21, $00
                 
0003a5 2745          EOR r20, r21
                 
0003a6 b72f          IN  r18, SREG_ADDR  ; Read the Status register
0003a7 9320 0100     STS $0100, r18      ;W 14 0100
0003a9 9340 0100     STS $0100, r20      ;W FF 0100
0003ab 9350 0100     STS $0100, r21      ;W 00 0100
                 
                 test_eor_both_ones:
0003ad ef4f          LDI r20, $FF
0003ae ef5f          LDI r21, $FF
                 
0003af 2745          EOR r20, r21
                 
0003b0 b72f          IN  r18, SREG_ADDR  ; Read the Status register
0003b1 9320 0100     STS $0100, r18      ;W 02 0100
0003b3 9340 0100     STS $0100, r20      ;W 00 0100
0003b5 9350 0100     STS $0100, r21      ;W FF 0100
                 
                 test_eor_random:
0003b7 e947          LDI r20, $97        ; 10010111
0003b8 ea54          LDI r21, $A4        ; 10100100
                                         ; 00110011
                 
0003b9 2745          EOR r20, r21
                 
0003ba b72f          IN  r18, SREG_ADDR  ; Read the Status register
0003bb 9320 0100     STS $0100, r18      ;W 00 0100
0003bd 9340 0100     STS $0100, r20      ;W 33 0100
0003bf 9350 0100     STS $0100, r21      ;W A4 0100
                 
                 ;PREPROCESS TestINC
                 start_inc:
0003c1 9488
0003c2 9498
0003c3 94a8
0003c4 94b8
0003c5 94c8
0003c6 94d8
0003c7 94e8
0003c8 94f8          CLR_SREG
                 test_inc_unsigned:
0003c9 efbe          LDI r27, $FE        ; Initialize to 254
                 
0003ca 95b3          INC r27
0003cb b72f          IN  r18, SREG_ADDR  ; Read the Status register
0003cc 9320 0100     STS $0100, r18      ;W 14 0100
0003ce 93b0 0100     STS $0100, r27      ;W FF 0100
                 
0003d0 95b3          INC r27
0003d1 b72f          IN  r18, SREG_ADDR  ; Read the Status register
0003d2 9320 0100     STS $0100, r18      ;W 02 0100
0003d4 93b0 0100     STS $0100, r27      ;W 00 0100
                 
0003d6 95b3          INC r27
0003d7 b72f          IN  r18, SREG_ADDR  ; Read the Status register
0003d8 9320 0100     STS $0100, r18      ;W 00 0100
0003da 93b0 0100     STS $0100, r27      ;W 01 0100
                 
0003dc 95b3          INC r27
0003dd b72f          IN  r18, SREG_ADDR  ; Read the Status register
0003de 9320 0100     STS $0100, r18      ;W 00 0100
0003e0 93b0 0100     STS $0100, r27      ;W 02 0100
                 
                 test_inc_signed:
0003e2 e7be          LDI r27, $7E        ; Initialize to 126
                 
0003e3 95b3          INC r27
0003e4 b72f          IN  r18, SREG_ADDR  ; Read the Status register
0003e5 9320 0100     STS $0100, r18      ;W 00 0100
0003e7 93b0 0100     STS $0100, r27      ;W 7F 0100
                 
0003e9 95b3          INC r27
0003ea b72f          IN  r18, SREG_ADDR  ; Read the Status register
0003eb 9320 0100     STS $0100, r18      ;W 0C 0100
0003ed 93b0 0100     STS $0100, r27      ;W 80 0100
                 
0003ef 95b3          INC r27
0003f0 b72f          IN  r18, SREG_ADDR  ; Read the Status register
0003f1 9320 0100     STS $0100, r18      ;W 14 0100
0003f3 93b0 0100     STS $0100, r27      ;W 81 0100
                 
                 
                 test_success:
0003f5 0000          NOP;
0003f6 0000          NOP;
                 
                 test_failure:
0003f7 0000          NOP         ; Put a breakpoint on this line
                 ;    RET          RET inst not allowed ; Return to the point where failure occurred, for debugging
0003f8 0000          NOP;
                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega88" register use summary:
r0 :   0 r1 :   0 r2 :   0 r3 :  32 r4 :   9 r5 :   0 r6 :  15 r7 :   9 
r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 r13:   0 r14:   0 r15:   0 
r16:  47 r17:  95 r18: 216 r19:   8 r20:  64 r21:  33 r22:  14 r23:   8 
r24:  33 r25:  24 r26:  13 r27:  45 r28:   0 r29:   0 r30:   0 r31:   0 
x  :  39 y  :   0 z  :   0 
Registers used: 17 out of 35 (48.6%)

"ATmega88" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   8 add   :   5 adiw  :   8 and   :   3 
andi  :   3 asr   :  16 bclr  : 169 bld   :  24 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   0 break :   0 breq  :   0 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   0 
brne  :   0 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :  30 bst   :  16 cbi   :   0 cbr   :   0 clc   :   0 
clh   :   0 cli   :   0 cln   :   0 clr   :   0 cls   :   0 clt   :   0 
clv   :   0 clz   :   0 com   :   6 cp    :   4 cpc   :   4 cpi   :   4 
cpse  :   0 dec   :   7 eor   :   5 fmul  :   0 fmuls :   0 fmulsu:   0 
icall :   0 ijmp  :   0 in    : 108 inc   :   7 ld    :   0 ldd   :   0 
ldi   : 134 lds   :   0 lpm   :   0 lsl   :   0 lsr   :   0 mov   :  13 
movw  :   0 mul   :   0 muls  :   0 mulsu :   0 neg   :   0 nop   :   4 
or    :   0 ori   :   0 out   :   2 pop   :   0 push  :   0 rcall :   0 
ret   :   0 reti  :   0 rjmp  :   0 rol   :   0 ror   :   0 sbc   :   0 
sbci  :   0 sbi   :   0 sbic  :   0 sbis  :   0 sbiw  :   0 sbr   :   0 
sbrc  :   0 sbrs  :   0 sec   :   0 seh   :   0 sei   :   0 sen   :   0 
ser   :   0 ses   :   0 set   :   0 sev   :   0 sez   :   0 sleep :   0 
spm   :   0 st    :  39 std   :   0 sts   : 199 sub   :   0 subi  :   0 
swap  :   0 tst   :   0 wdr   :   0 
Instructions used: 24 out of 111 (21.6%)

"ATmega88" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0007f2   2034      0   2034    8192  24.8%
[.dseg] 0x000100 0x000100      0      0      0    1024   0.0%
[.eseg] 0x000000 0x000000      0      0      0     512   0.0%

Assembly complete, 0 errors, 0 warnings
